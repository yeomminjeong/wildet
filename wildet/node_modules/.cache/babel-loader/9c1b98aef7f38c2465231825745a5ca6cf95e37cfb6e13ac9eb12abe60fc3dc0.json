{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { tidy, util } from '@tensorflow/tfjs-core';\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\nimport { getParamValue } from './utils';\nexport const executeOp = function (node, tensorMap, context) {\n  let ops = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : tfOps;\n  switch (node.op) {\n    case 'ConcatV2':\n    case 'Concat':\n      {\n        const n = getParamValue('n', node, tensorMap, context);\n        const axis = getParamValue('axis', node, tensorMap, context);\n        let inputs = getParamValue('tensors', node, tensorMap, context);\n        inputs = inputs.slice(0, n);\n        return [ops.concat(inputs, axis)];\n      }\n    case 'Gather':\n      {\n        const input = getParamValue('x', node, tensorMap, context);\n        const indices = getParamValue('indices', node, tensorMap, context);\n        return [ops.gather(input, ops.cast(indices, 'int32'), 0)];\n      }\n    case 'GatherV2':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const batchDims = getParamValue('batchDims', node, tensorMap, context);\n        const input = getParamValue('x', node, tensorMap, context);\n        const indices = getParamValue('indices', node, tensorMap, context);\n        return [ops.gather(input, ops.cast(indices, 'int32'), axis, batchDims)];\n      }\n    case 'Reverse':\n      {\n        const dims = getParamValue('dims', node, tensorMap, context);\n        const axis = [];\n        for (let i = 0; i < dims.length; i++) {\n          if (dims[i]) {\n            axis.push(i);\n          }\n        }\n        const input = getParamValue('x', node, tensorMap, context);\n        return [ops.reverse(input, axis)];\n      }\n    case 'ReverseV2':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const input = getParamValue('x', node, tensorMap, context);\n        return [ops.reverse(input, axis)];\n      }\n    case 'Slice':\n      {\n        // tslint:disable-next-line:no-any\n        const begin = getParamValue('begin', node, tensorMap, context);\n        // tslint:disable-next-line:no-any\n        const size = getParamValue('size', node, tensorMap, context);\n        return [ops.slice(getParamValue('x', node, tensorMap, context), begin, size)];\n      }\n    case 'StridedSlice':\n      {\n        const begin = getParamValue('begin', node, tensorMap, context);\n        const end = getParamValue('end', node, tensorMap, context);\n        const strides = getParamValue('strides', node, tensorMap, context);\n        const beginMask = getParamValue('beginMask', node, tensorMap, context);\n        const endMask = getParamValue('endMask', node, tensorMap, context);\n        const ellipsisMask = getParamValue('ellipsisMask', node, tensorMap, context);\n        const newAxisMask = getParamValue('newAxisMask', node, tensorMap, context);\n        const shrinkAxisMask = getParamValue('shrinkAxisMask', node, tensorMap, context);\n        const tensor = getParamValue('x', node, tensorMap, context);\n        return [ops.stridedSlice(tensor, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask)];\n      }\n    case 'Pack':\n      {\n        return tidy(() => {\n          const axis = getParamValue('axis', node, tensorMap, context);\n          const tensors = getParamValue('tensors', node, tensorMap, context);\n          // Reshape the tensors to the first tensor's shape if they don't\n          // match.\n          const shape = tensors[0].shape;\n          const squeezedShape = ops.squeeze(tensors[0]).shape;\n          const mapped = tensors.map(tensor => {\n            const sameShape = util.arraysEqual(tensor.shape, shape);\n            if (!sameShape && !util.arraysEqual(ops.squeeze(tensor).shape, squeezedShape)) {\n              throw new Error('the input tensors shape does not match');\n            }\n            return sameShape ? tensor : ops.reshape(tensor, shape);\n          });\n          return [ops.stack(mapped, axis)];\n        });\n      }\n    case 'Unpack':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const tensor = getParamValue('tensor', node, tensorMap, context);\n        return ops.unstack(tensor, axis);\n      }\n    case 'Tile':\n      {\n        const reps = getParamValue('reps', node, tensorMap, context);\n        return [ops.tile(getParamValue('x', node, tensorMap, context), reps)];\n      }\n    case 'Split':\n    case 'SplitV':\n      {\n        const axis = getParamValue('axis', node, tensorMap, context);\n        const numOrSizeSplits = getParamValue('numOrSizeSplits', node, tensorMap, context);\n        const tensor = getParamValue('x', node, tensorMap, context);\n        return ops.split(tensor, numOrSizeSplits, axis);\n      }\n    case 'ScatterNd':\n      {\n        const indices = getParamValue('indices', node, tensorMap, context);\n        const values = getParamValue('values', node, tensorMap, context);\n        const shape = getParamValue('shape', node, tensorMap, context);\n        return [ops.scatterND(indices, values, shape)];\n      }\n    case 'GatherNd':\n      {\n        const x = getParamValue('x', node, tensorMap, context);\n        const indices = getParamValue('indices', node, tensorMap, context);\n        return [ops.gatherND(x, indices)];\n      }\n    case 'SparseToDense':\n      {\n        const indices = getParamValue('sparseIndices', node, tensorMap, context);\n        const shape = getParamValue('outputShape', node, tensorMap, context);\n        const sparseValues = getParamValue('sparseValues', node, tensorMap, context);\n        const defaultValue = getParamValue('defaultValue', node, tensorMap, context);\n        return [ops.sparseToDense(indices, sparseValues, shape, sparseValues.dtype === defaultValue.dtype ? defaultValue : ops.cast(defaultValue, sparseValues.dtype))];\n      }\n    case 'TensorScatterUpdate':\n      {\n        const indices = getParamValue('indices', node, tensorMap, context);\n        const values = getParamValue('values', node, tensorMap, context);\n        const tensor = getParamValue('tensor', node, tensorMap, context);\n        return [ops.tensorScatterUpdate(tensor, indices, values)];\n      }\n    default:\n      throw TypeError(`Node type ${node.op} is not implemented`);\n  }\n};\nexport const CATEGORY = 'slice_join';","map":{"version":3,"names":["tidy","util","tfOps","getParamValue","executeOp","node","tensorMap","context","ops","arguments","length","undefined","op","n","axis","inputs","slice","concat","input","indices","gather","cast","batchDims","dims","i","push","reverse","begin","size","end","strides","beginMask","endMask","ellipsisMask","newAxisMask","shrinkAxisMask","tensor","stridedSlice","tensors","shape","squeezedShape","squeeze","mapped","map","sameShape","arraysEqual","Error","reshape","stack","unstack","reps","tile","numOrSizeSplits","split","values","scatterND","x","gatherND","sparseValues","defaultValue","sparseToDense","dtype","tensorScatterUpdate","TypeError","CATEGORY"],"sources":["/Users/minjeongyeom/Projects/project-wildet/tfjs-converter/src/operations/executors/slice_join_executor.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Scalar, Tensor, Tensor1D, tidy, util} from '@tensorflow/tfjs-core';\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\n\nimport {NamedTensorsMap} from '../../data/types';\nimport {ExecutionContext} from '../../executor/execution_context';\nimport {InternalOpExecutor, Node} from '../types';\n\nimport {getParamValue} from './utils';\n\nexport const executeOp: InternalOpExecutor =\n    (node: Node, tensorMap: NamedTensorsMap, context: ExecutionContext,\n     ops = tfOps): Tensor[] => {\n      switch (node.op) {\n        case 'ConcatV2':\n        case 'Concat': {\n          const n = getParamValue('n', node, tensorMap, context) as number;\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number;\n          let inputs =\n              getParamValue('tensors', node, tensorMap, context) as Tensor[];\n          inputs = inputs.slice(0, n);\n          return [ops.concat(inputs, axis)];\n        }\n        case 'Gather': {\n          const input = getParamValue('x', node, tensorMap, context) as Tensor;\n          const indices =\n              getParamValue('indices', node, tensorMap, context) as Tensor1D;\n          return [ops.gather(input, ops.cast(indices, 'int32'), 0)];\n        }\n        case 'GatherV2': {\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number;\n          const batchDims =\n              getParamValue('batchDims', node, tensorMap, context) as number;\n          const input = getParamValue('x', node, tensorMap, context) as Tensor;\n          const indices =\n              getParamValue('indices', node, tensorMap, context) as Tensor1D;\n          return [ops.gather(\n              input, ops.cast(indices, 'int32'), axis, batchDims)];\n        }\n        case 'Reverse': {\n          const dims =\n              getParamValue('dims', node, tensorMap, context) as boolean[];\n          const axis = [];\n          for (let i = 0; i < dims.length; i++) {\n            if (dims[i]) {\n              axis.push(i);\n            }\n          }\n          const input = getParamValue('x', node, tensorMap, context) as Tensor;\n          return [ops.reverse(input, axis)];\n        }\n        case 'ReverseV2': {\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number[];\n          const input = getParamValue('x', node, tensorMap, context) as Tensor;\n          return [ops.reverse(input, axis)];\n        }\n        case 'Slice': {\n          // tslint:disable-next-line:no-any\n          const begin = getParamValue('begin', node, tensorMap, context) as any;\n          // tslint:disable-next-line:no-any\n          const size = getParamValue('size', node, tensorMap, context) as any;\n          return [ops.slice(\n              getParamValue('x', node, tensorMap, context) as Tensor, begin,\n              size)];\n        }\n        case 'StridedSlice': {\n          const begin =\n              getParamValue('begin', node, tensorMap, context) as number[];\n          const end =\n              getParamValue('end', node, tensorMap, context) as number[];\n          const strides =\n              getParamValue('strides', node, tensorMap, context) as number[];\n          const beginMask =\n              getParamValue('beginMask', node, tensorMap, context) as number;\n          const endMask =\n              getParamValue('endMask', node, tensorMap, context) as number;\n          const ellipsisMask =\n              getParamValue('ellipsisMask', node, tensorMap, context) as number;\n          const newAxisMask =\n              getParamValue('newAxisMask', node, tensorMap, context) as number;\n          const shrinkAxisMask =\n              getParamValue('shrinkAxisMask', node, tensorMap, context) as\n              number;\n          const tensor = getParamValue('x', node, tensorMap, context) as Tensor;\n\n          return [ops.stridedSlice(\n              tensor, begin, end, strides, beginMask, endMask, ellipsisMask,\n              newAxisMask, shrinkAxisMask)];\n        }\n        case 'Pack': {\n          return tidy(() => {\n            const axis =\n                getParamValue('axis', node, tensorMap, context) as number;\n            const tensors =\n                getParamValue('tensors', node, tensorMap, context) as Tensor[];\n            // Reshape the tensors to the first tensor's shape if they don't\n            // match.\n            const shape = tensors[0].shape;\n            const squeezedShape = ops.squeeze(tensors[0]).shape;\n            const mapped = tensors.map(tensor => {\n              const sameShape = util.arraysEqual(tensor.shape, shape);\n              if (!sameShape &&\n                  !util.arraysEqual(ops.squeeze(tensor).shape, squeezedShape)) {\n                throw new Error('the input tensors shape does not match');\n              }\n              return sameShape ? tensor : ops.reshape(tensor, shape);\n            });\n            return [ops.stack(mapped, axis)];\n          });\n        }\n        case 'Unpack': {\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number;\n          const tensor =\n              getParamValue('tensor', node, tensorMap, context) as Tensor;\n          return ops.unstack(tensor, axis);\n        }\n        case 'Tile': {\n          const reps =\n              getParamValue('reps', node, tensorMap, context) as number[];\n          return [ops.tile(\n              getParamValue('x', node, tensorMap, context) as Tensor, reps)];\n        }\n        case 'Split':\n        case 'SplitV': {\n          const axis =\n              getParamValue('axis', node, tensorMap, context) as number;\n          const numOrSizeSplits =\n              getParamValue('numOrSizeSplits', node, tensorMap, context) as\n                  number |\n              number[];\n          const tensor = getParamValue('x', node, tensorMap, context) as Tensor;\n\n          return ops.split(tensor, numOrSizeSplits, axis);\n        }\n        case 'ScatterNd': {\n          const indices =\n              getParamValue('indices', node, tensorMap, context) as Tensor;\n          const values =\n              getParamValue('values', node, tensorMap, context) as Tensor;\n          const shape =\n              getParamValue('shape', node, tensorMap, context) as number[];\n          return [ops.scatterND(indices, values, shape)];\n        }\n        case 'GatherNd': {\n          const x = getParamValue('x', node, tensorMap, context) as Tensor;\n          const indices =\n              getParamValue('indices', node, tensorMap, context) as Tensor;\n          return [ops.gatherND(x, indices)];\n        }\n        case 'SparseToDense': {\n          const indices =\n              getParamValue('sparseIndices', node, tensorMap, context) as\n              Tensor;\n          const shape =\n              getParamValue('outputShape', node, tensorMap, context) as\n              number[];\n          const sparseValues =\n              getParamValue('sparseValues', node, tensorMap, context) as Tensor;\n          const defaultValue =\n              getParamValue('defaultValue', node, tensorMap, context) as Scalar;\n          return [ops.sparseToDense(\n              indices, sparseValues, shape,\n              sparseValues.dtype === defaultValue.dtype ?\n                  defaultValue :\n                  ops.cast(defaultValue, sparseValues.dtype))];\n        }\n        case 'TensorScatterUpdate': {\n          const indices =\n              getParamValue('indices', node, tensorMap, context) as Tensor;\n          const values =\n              getParamValue('values', node, tensorMap, context) as Tensor;\n          const tensor =\n              getParamValue('tensor', node, tensorMap, context) as Tensor;\n          return [ops.tensorScatterUpdate(tensor, indices, values)];\n        }\n        default:\n          throw TypeError(`Node type ${node.op} is not implemented`);\n      }\n    };\n\nexport const CATEGORY = 'slice_join';\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
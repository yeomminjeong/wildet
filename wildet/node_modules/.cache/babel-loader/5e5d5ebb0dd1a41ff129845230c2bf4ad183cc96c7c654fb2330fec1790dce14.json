{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { env, tensor, util } from '@tensorflow/tfjs-core';\nimport { LazyIterator } from './lazy_iterator';\n/**\n * Provide a stream of tensors from microphone audio stream. The tensors are\n * representing audio data as frequency-domain spectrogram generated with\n * browser's native FFT. Tensors representing time-domain waveform is available\n * based on configuration. Only works in browser environment.\n */\nexport class MicrophoneIterator extends LazyIterator {\n  constructor(microphoneConfig) {\n    super();\n    this.microphoneConfig = microphoneConfig;\n    this.isClosed = false;\n    this.fftSize = microphoneConfig.fftSize || 1024;\n    const fftSizeLog2 = Math.log2(this.fftSize);\n    if (this.fftSize < 0 || fftSizeLog2 < 4 || fftSizeLog2 > 14 || !Number.isInteger(fftSizeLog2)) {\n      throw new Error(`Invalid fftSize: it must be a power of 2 between ` + `2 to 4 and 2 to 14, but got ${this.fftSize}`);\n    }\n    this.numFrames = microphoneConfig.numFramesPerSpectrogram || 43;\n    this.sampleRateHz = microphoneConfig.sampleRateHz;\n    this.columnTruncateLength = microphoneConfig.columnTruncateLength || this.fftSize;\n    this.audioTrackConstraints = microphoneConfig.audioTrackConstraints;\n    this.smoothingTimeConstant = microphoneConfig.smoothingTimeConstant || 0;\n    this.includeSpectrogram = microphoneConfig.includeSpectrogram === false ? false : true;\n    this.includeWaveform = microphoneConfig.includeWaveform === true ? true : false;\n    if (!this.includeSpectrogram && !this.includeWaveform) {\n      throw new Error('Both includeSpectrogram and includeWaveform are false. ' + 'At least one type of data should be returned.');\n    }\n  }\n  summary() {\n    return `microphone`;\n  }\n  // Construct a MicrophoneIterator and start the audio stream.\n  static async create() {\n    let microphoneConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!env().get('IS_BROWSER')) {\n      throw new Error('microphone API is only supported in browser environment.');\n    }\n    const microphoneIterator = new MicrophoneIterator(microphoneConfig);\n    // Call async function start() to initialize the audio stream.\n    await microphoneIterator.start();\n    return microphoneIterator;\n  }\n  // Start the audio stream and FFT.\n  async start() {\n    try {\n      this.stream = await navigator.mediaDevices.getUserMedia({\n        audio: this.audioTrackConstraints == null ? true : this.audioTrackConstraints,\n        video: false\n      });\n    } catch (e) {\n      throw new Error(`Error thrown while initializing video stream: ${e.message}`);\n    }\n    if (!this.stream) {\n      throw new Error('Could not obtain audio from microphone.');\n    }\n    const ctxConstructor =\n    // tslint:disable-next-line:no-any\n    window.AudioContext || window.webkitAudioContext;\n    this.audioContext = new ctxConstructor();\n    if (!this.sampleRateHz) {\n      // If sample rate is not provided, use the available sample rate on\n      // device.\n      this.sampleRateHz = this.audioContext.sampleRate;\n    } else if (this.audioContext.sampleRate !== this.sampleRateHz) {\n      throw new Error(`Mismatch in sampling rate: ` + `Expected: ${this.sampleRateHz}; ` + `Actual: ${this.audioContext.sampleRate}`);\n    }\n    const streamSource = this.audioContext.createMediaStreamSource(this.stream);\n    this.analyser = this.audioContext.createAnalyser();\n    this.analyser.fftSize = this.fftSize * 2;\n    this.analyser.smoothingTimeConstant = this.smoothingTimeConstant;\n    streamSource.connect(this.analyser);\n    this.freqData = new Float32Array(this.fftSize);\n    this.timeData = new Float32Array(this.fftSize);\n    return;\n  }\n  async next() {\n    if (this.isClosed) {\n      return {\n        value: null,\n        done: true\n      };\n    }\n    let spectrogramTensor;\n    let waveformTensor;\n    const audioDataQueue = await this.getAudioData();\n    if (this.includeSpectrogram) {\n      const freqData = this.flattenQueue(audioDataQueue.freqDataQueue);\n      spectrogramTensor = this.getTensorFromAudioDataArray(freqData, [this.numFrames, this.columnTruncateLength, 1]);\n    }\n    if (this.includeWaveform) {\n      const timeData = this.flattenQueue(audioDataQueue.timeDataQueue);\n      waveformTensor = this.getTensorFromAudioDataArray(timeData, [this.numFrames * this.fftSize, 1]);\n    }\n    return {\n      value: {\n        'spectrogram': spectrogramTensor,\n        'waveform': waveformTensor\n      },\n      done: false\n    };\n  }\n  // Capture one result from the audio stream, and extract the value from\n  // iterator.next() result.\n  async capture() {\n    return (await this.next()).value;\n  }\n  async getAudioData() {\n    const freqDataQueue = [];\n    const timeDataQueue = [];\n    let currentFrames = 0;\n    return new Promise(resolve => {\n      const intervalID = setInterval(() => {\n        if (this.includeSpectrogram) {\n          this.analyser.getFloatFrequencyData(this.freqData);\n          // If the audio stream is initializing, return empty queue.\n          if (this.freqData[0] === -Infinity) {\n            resolve({\n              freqDataQueue,\n              timeDataQueue\n            });\n          }\n          freqDataQueue.push(this.freqData.slice(0, this.columnTruncateLength));\n        }\n        if (this.includeWaveform) {\n          this.analyser.getFloatTimeDomainData(this.timeData);\n          timeDataQueue.push(this.timeData.slice());\n        }\n        // Clean interval and return when all frames have been collected\n        if (++currentFrames === this.numFrames) {\n          clearInterval(intervalID);\n          resolve({\n            freqDataQueue,\n            timeDataQueue\n          });\n        }\n      }, this.fftSize / this.sampleRateHz * 1e3);\n    });\n  }\n  // Stop the audio stream and pause the iterator.\n  stop() {\n    if (!this.isClosed) {\n      this.isClosed = true;\n      this.analyser.disconnect();\n      this.audioContext.close();\n      if (this.stream != null && this.stream.getTracks().length > 0) {\n        this.stream.getTracks()[0].stop();\n      }\n    }\n  }\n  // Override toArray() function to prevent collecting.\n  toArray() {\n    throw new Error('Can not convert infinite audio stream to array.');\n  }\n  // Return audio sampling rate in Hz\n  getSampleRate() {\n    return this.sampleRateHz;\n  }\n  flattenQueue(queue) {\n    const frameSize = queue[0].length;\n    const freqData = new Float32Array(queue.length * frameSize);\n    queue.forEach((data, i) => freqData.set(data, i * frameSize));\n    return freqData;\n  }\n  getTensorFromAudioDataArray(freqData, shape) {\n    const vals = new Float32Array(util.sizeFromShape(shape));\n    // If the data is less than the output shape, the rest is padded with zeros.\n    vals.set(freqData, vals.length - freqData.length);\n    return tensor(vals, shape);\n  }\n}","map":{"version":3,"names":["env","tensor","util","LazyIterator","MicrophoneIterator","constructor","microphoneConfig","isClosed","fftSize","fftSizeLog2","Math","log2","Number","isInteger","Error","numFrames","numFramesPerSpectrogram","sampleRateHz","columnTruncateLength","audioTrackConstraints","smoothingTimeConstant","includeSpectrogram","includeWaveform","summary","create","arguments","length","undefined","get","microphoneIterator","start","stream","navigator","mediaDevices","getUserMedia","audio","video","e","message","ctxConstructor","window","AudioContext","webkitAudioContext","audioContext","sampleRate","streamSource","createMediaStreamSource","analyser","createAnalyser","connect","freqData","Float32Array","timeData","next","value","done","spectrogramTensor","waveformTensor","audioDataQueue","getAudioData","flattenQueue","freqDataQueue","getTensorFromAudioDataArray","timeDataQueue","capture","currentFrames","Promise","resolve","intervalID","setInterval","getFloatFrequencyData","Infinity","push","slice","getFloatTimeDomainData","clearInterval","stop","disconnect","close","getTracks","toArray","getSampleRate","queue","frameSize","forEach","data","i","set","shape","vals","sizeFromShape"],"sources":["/Users/minjeongyeom/Projects/project-wildet/tfjs-data/src/iterators/microphone_iterator.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n\nimport {env, Tensor, tensor, Tensor2D, Tensor3D, TensorContainer, util} from '@tensorflow/tfjs-core';\nimport {MicrophoneConfig} from '../types';\nimport {LazyIterator} from './lazy_iterator';\n\n/**\n * Provide a stream of tensors from microphone audio stream. The tensors are\n * representing audio data as frequency-domain spectrogram generated with\n * browser's native FFT. Tensors representing time-domain waveform is available\n * based on configuration. Only works in browser environment.\n */\nexport class MicrophoneIterator extends LazyIterator<TensorContainer> {\n  private isClosed = false;\n  private stream: MediaStream;\n  private readonly fftSize: number;\n  private readonly columnTruncateLength: number;\n  private freqData: Float32Array;\n  private timeData: Float32Array;\n  private readonly numFrames: number;\n  private analyser: AnalyserNode;\n  private audioContext: AudioContext;\n  private sampleRateHz: number;\n  private readonly audioTrackConstraints: MediaTrackConstraints;\n  private readonly smoothingTimeConstant: number;\n  private readonly includeSpectrogram: boolean;\n  private readonly includeWaveform: boolean;\n\n  private constructor(protected readonly microphoneConfig: MicrophoneConfig) {\n    super();\n    this.fftSize = microphoneConfig.fftSize || 1024;\n    const fftSizeLog2 = Math.log2(this.fftSize);\n    if (this.fftSize < 0 || fftSizeLog2 < 4 || fftSizeLog2 > 14 ||\n        !Number.isInteger(fftSizeLog2)) {\n      throw new Error(\n          `Invalid fftSize: it must be a power of 2 between ` +\n          `2 to 4 and 2 to 14, but got ${this.fftSize}`);\n    }\n\n    this.numFrames = microphoneConfig.numFramesPerSpectrogram || 43;\n    this.sampleRateHz = microphoneConfig.sampleRateHz;\n    this.columnTruncateLength =\n        microphoneConfig.columnTruncateLength || this.fftSize;\n    this.audioTrackConstraints = microphoneConfig.audioTrackConstraints;\n    this.smoothingTimeConstant = microphoneConfig.smoothingTimeConstant || 0;\n\n    this.includeSpectrogram =\n        microphoneConfig.includeSpectrogram === false ? false : true;\n    this.includeWaveform =\n        microphoneConfig.includeWaveform === true ? true : false;\n    if (!this.includeSpectrogram && !this.includeWaveform) {\n      throw new Error(\n          'Both includeSpectrogram and includeWaveform are false. ' +\n          'At least one type of data should be returned.');\n    }\n  }\n\n  summary() {\n    return `microphone`;\n  }\n\n  // Construct a MicrophoneIterator and start the audio stream.\n  static async create(microphoneConfig: MicrophoneConfig = {}) {\n    if (!env().get('IS_BROWSER')) {\n      throw new Error(\n          'microphone API is only supported in browser environment.');\n    }\n\n    const microphoneIterator = new MicrophoneIterator(microphoneConfig);\n\n    // Call async function start() to initialize the audio stream.\n    await microphoneIterator.start();\n\n    return microphoneIterator;\n  }\n\n  // Start the audio stream and FFT.\n  async start(): Promise<void> {\n    try {\n      this.stream = await navigator.mediaDevices.getUserMedia({\n        audio: this.audioTrackConstraints == null ? true :\n                                                    this.audioTrackConstraints,\n        video: false\n      });\n    } catch (e) {\n      throw new Error(\n          `Error thrown while initializing video stream: ${e.message}`);\n    }\n\n    if (!this.stream) {\n      throw new Error('Could not obtain audio from microphone.');\n    }\n\n    const ctxConstructor =\n        // tslint:disable-next-line:no-any\n        (window as any).AudioContext || (window as any).webkitAudioContext;\n    this.audioContext = new ctxConstructor();\n\n    if (!this.sampleRateHz) {\n      // If sample rate is not provided, use the available sample rate on\n      // device.\n      this.sampleRateHz = this.audioContext.sampleRate;\n    } else if (this.audioContext.sampleRate !== this.sampleRateHz) {\n      throw new Error(\n          `Mismatch in sampling rate: ` +\n          `Expected: ${this.sampleRateHz}; ` +\n          `Actual: ${this.audioContext.sampleRate}`);\n    }\n\n    const streamSource = this.audioContext.createMediaStreamSource(this.stream);\n    this.analyser = this.audioContext.createAnalyser();\n    this.analyser.fftSize = this.fftSize * 2;\n    this.analyser.smoothingTimeConstant = this.smoothingTimeConstant;\n    streamSource.connect(this.analyser);\n    this.freqData = new Float32Array(this.fftSize);\n    this.timeData = new Float32Array(this.fftSize);\n    return;\n  }\n\n  async next(): Promise<IteratorResult<TensorContainer>> {\n    if (this.isClosed) {\n      return {value: null, done: true};\n    }\n\n    let spectrogramTensor: Tensor;\n    let waveformTensor: Tensor;\n\n    const audioDataQueue = await this.getAudioData();\n    if (this.includeSpectrogram) {\n      const freqData = this.flattenQueue(audioDataQueue.freqDataQueue);\n      spectrogramTensor = this.getTensorFromAudioDataArray(\n          freqData, [this.numFrames, this.columnTruncateLength, 1]);\n    }\n    if (this.includeWaveform) {\n      const timeData = this.flattenQueue(audioDataQueue.timeDataQueue);\n      waveformTensor = this.getTensorFromAudioDataArray(\n          timeData, [this.numFrames * this.fftSize, 1]);\n    }\n\n    return {\n      value: {'spectrogram': spectrogramTensor, 'waveform': waveformTensor},\n      done: false\n    };\n  }\n\n  // Capture one result from the audio stream, and extract the value from\n  // iterator.next() result.\n  async capture(): Promise<{spectrogram: Tensor3D, waveform: Tensor2D}> {\n    return (await this.next()).value as\n        {spectrogram: Tensor3D, waveform: Tensor2D};\n  }\n\n  private async getAudioData():\n      Promise<{freqDataQueue: Float32Array[], timeDataQueue: Float32Array[]}> {\n    const freqDataQueue: Float32Array[] = [];\n    const timeDataQueue: Float32Array[] = [];\n    let currentFrames = 0;\n    return new Promise(resolve => {\n      const intervalID = setInterval(() => {\n        if (this.includeSpectrogram) {\n          this.analyser.getFloatFrequencyData(this.freqData);\n          // If the audio stream is initializing, return empty queue.\n          if (this.freqData[0] === -Infinity) {\n            resolve({freqDataQueue, timeDataQueue});\n          }\n          freqDataQueue.push(this.freqData.slice(0, this.columnTruncateLength));\n        }\n        if (this.includeWaveform) {\n          this.analyser.getFloatTimeDomainData(this.timeData);\n          timeDataQueue.push(this.timeData.slice());\n        }\n\n        // Clean interval and return when all frames have been collected\n        if (++currentFrames === this.numFrames) {\n          clearInterval(intervalID);\n          resolve({freqDataQueue, timeDataQueue});\n        }\n      }, this.fftSize / this.sampleRateHz * 1e3);\n    });\n  }\n\n  // Stop the audio stream and pause the iterator.\n  stop(): void {\n    if (!this.isClosed) {\n      this.isClosed = true;\n      this.analyser.disconnect();\n      this.audioContext.close();\n      if (this.stream != null && this.stream.getTracks().length > 0) {\n        this.stream.getTracks()[0].stop();\n      }\n    }\n  }\n\n  // Override toArray() function to prevent collecting.\n  override toArray(): Promise<Tensor[]> {\n    throw new Error('Can not convert infinite audio stream to array.');\n  }\n\n  // Return audio sampling rate in Hz\n  getSampleRate(): number {\n    return this.sampleRateHz;\n  }\n\n  private flattenQueue(queue: Float32Array[]): Float32Array {\n    const frameSize = queue[0].length;\n    const freqData = new Float32Array(queue.length * frameSize);\n    queue.forEach((data, i) => freqData.set(data, i * frameSize));\n    return freqData;\n  }\n\n  private getTensorFromAudioDataArray(freqData: Float32Array, shape: number[]):\n      Tensor {\n    const vals = new Float32Array(util.sizeFromShape(shape));\n    // If the data is less than the output shape, the rest is padded with zeros.\n    vals.set(freqData, vals.length - freqData.length);\n    return tensor(vals, shape);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
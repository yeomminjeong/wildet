{"ast":null,"code":"import _regeneratorRuntime from \"/Users/minjeongyeom/Projects/project-wildet/wildet/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _slicedToArray from \"/Users/minjeongyeom/Projects/project-wildet/wildet/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _asyncToGenerator from \"/Users/minjeongyeom/Projects/project-wildet/wildet/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createForOfIteratorHelper from \"/Users/minjeongyeom/Projects/project-wildet/wildet/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/minjeongyeom/Projects/project-wildet/wildet/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/minjeongyeom/Projects/project-wildet/wildet/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/minjeongyeom/Projects/project-wildet/wildet/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { waitUntil } from 'workbox-core/_private/waitUntil.js';\nimport { createCacheKey } from './utils/createCacheKey.js';\nimport { PrecacheInstallReportPlugin } from './utils/PrecacheInstallReportPlugin.js';\nimport { PrecacheCacheKeyPlugin } from './utils/PrecacheCacheKeyPlugin.js';\nimport { printCleanupDetails } from './utils/printCleanupDetails.js';\nimport { printInstallDetails } from './utils/printInstallDetails.js';\nimport { PrecacheStrategy } from './PrecacheStrategy.js';\nimport './_version.js';\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof workbox-precaching\n */\nvar PrecacheController = /*#__PURE__*/function () {\n  /**\n   * Create a new PrecacheController.\n   *\n   * @param {Object} [options]\n   * @param {string} [options.cacheName] The cache to use for precaching.\n   * @param {string} [options.plugins] Plugins to use when precaching as well\n   * as responding to fetch events for precached assets.\n   * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n   * get the response from the network if there's a precache miss.\n   */\n  function PrecacheController() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      cacheName = _ref.cacheName,\n      _ref$plugins = _ref.plugins,\n      plugins = _ref$plugins === void 0 ? [] : _ref$plugins,\n      _ref$fallbackToNetwor = _ref.fallbackToNetwork,\n      fallbackToNetwork = _ref$fallbackToNetwor === void 0 ? true : _ref$fallbackToNetwor;\n    _classCallCheck(this, PrecacheController);\n    this._urlsToCacheKeys = new Map();\n    this._urlsToCacheModes = new Map();\n    this._cacheKeysToIntegrities = new Map();\n    this._strategy = new PrecacheStrategy({\n      cacheName: cacheNames.getPrecacheName(cacheName),\n      plugins: [].concat(_toConsumableArray(plugins), [new PrecacheCacheKeyPlugin({\n        precacheController: this\n      })]),\n      fallbackToNetwork: fallbackToNetwork\n    });\n    // Bind the install and activate methods to the instance.\n    this.install = this.install.bind(this);\n    this.activate = this.activate.bind(this);\n  }\n  /**\n   * @type {workbox-precaching.PrecacheStrategy} The strategy created by this controller and\n   * used to cache assets and respond to fetch events.\n   */\n  _createClass(PrecacheController, [{\n    key: \"strategy\",\n    get: function get() {\n      return this._strategy;\n    }\n    /**\n     * Adds items to the precache list, removing any duplicates and\n     * stores the files in the\n     * {@link workbox-core.cacheNames|\"precache cache\"} when the service\n     * worker installs.\n     *\n     * This method can be called multiple times.\n     *\n     * @param {Array<Object|string>} [entries=[]] Array of entries to precache.\n     */\n  }, {\n    key: \"precache\",\n    value: function precache(entries) {\n      this.addToCacheList(entries);\n      if (!this._installAndActiveListenersAdded) {\n        self.addEventListener('install', this.install);\n        self.addEventListener('activate', this.activate);\n        this._installAndActiveListenersAdded = true;\n      }\n    }\n    /**\n     * This method will add items to the precache list, removing duplicates\n     * and ensuring the information is valid.\n     *\n     * @param {Array<workbox-precaching.PrecacheController.PrecacheEntry|string>} entries\n     *     Array of entries to precache.\n     */\n  }, {\n    key: \"addToCacheList\",\n    value: function addToCacheList(entries) {\n      if (process.env.NODE_ENV !== 'production') {\n        assert.isArray(entries, {\n          moduleName: 'workbox-precaching',\n          className: 'PrecacheController',\n          funcName: 'addToCacheList',\n          paramName: 'entries'\n        });\n      }\n      var urlsToWarnAbout = [];\n      var _iterator = _createForOfIteratorHelper(entries),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var entry = _step.value;\n          // See https://github.com/GoogleChrome/workbox/issues/2259\n          if (typeof entry === 'string') {\n            urlsToWarnAbout.push(entry);\n          } else if (entry && entry.revision === undefined) {\n            urlsToWarnAbout.push(entry.url);\n          }\n          var _createCacheKey = createCacheKey(entry),\n            cacheKey = _createCacheKey.cacheKey,\n            url = _createCacheKey.url;\n          var cacheMode = typeof entry !== 'string' && entry.revision ? 'reload' : 'default';\n          if (this._urlsToCacheKeys.has(url) && this._urlsToCacheKeys.get(url) !== cacheKey) {\n            throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n              firstEntry: this._urlsToCacheKeys.get(url),\n              secondEntry: cacheKey\n            });\n          }\n          if (typeof entry !== 'string' && entry.integrity) {\n            if (this._cacheKeysToIntegrities.has(cacheKey) && this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n              throw new WorkboxError('add-to-cache-list-conflicting-integrities', {\n                url: url\n              });\n            }\n            this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n          }\n          this._urlsToCacheKeys.set(url, cacheKey);\n          this._urlsToCacheModes.set(url, cacheMode);\n          if (urlsToWarnAbout.length > 0) {\n            var warningMessage = \"Workbox is precaching URLs without revision \" + \"info: \".concat(urlsToWarnAbout.join(', '), \"\\nThis is generally NOT safe. \") + \"Learn more at https://bit.ly/wb-precache\";\n            if (process.env.NODE_ENV === 'production') {\n              // Use console directly to display this warning without bloating\n              // bundle sizes by pulling in all of the logger codebase in prod.\n              console.warn(warningMessage);\n            } else {\n              logger.warn(warningMessage);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * Precaches new and updated assets. Call this method from the service worker\n     * install event.\n     *\n     * Note: this method calls `event.waitUntil()` for you, so you do not need\n     * to call it yourself in your event handlers.\n     *\n     * @param {ExtendableEvent} event\n     * @return {Promise<workbox-precaching.InstallResult>}\n     */\n  }, {\n    key: \"install\",\n    value: function install(event) {\n      var _this = this;\n      // waitUntil returns Promise<any>\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      return waitUntil(event, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var installReportPlugin, _iterator2, _step2, _step2$value, url, cacheKey, integrity, cacheMode, request, updatedURLs, notUpdatedURLs;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              installReportPlugin = new PrecacheInstallReportPlugin();\n              _this.strategy.plugins.push(installReportPlugin);\n              // Cache entries one at a time.\n              // See https://github.com/GoogleChrome/workbox/issues/2528\n              _iterator2 = _createForOfIteratorHelper(_this._urlsToCacheKeys);\n              _context.prev = 3;\n              _iterator2.s();\n            case 5:\n              if ((_step2 = _iterator2.n()).done) {\n                _context.next = 14;\n                break;\n              }\n              _step2$value = _slicedToArray(_step2.value, 2), url = _step2$value[0], cacheKey = _step2$value[1];\n              integrity = _this._cacheKeysToIntegrities.get(cacheKey);\n              cacheMode = _this._urlsToCacheModes.get(url);\n              request = new Request(url, {\n                integrity: integrity,\n                cache: cacheMode,\n                credentials: 'same-origin'\n              });\n              _context.next = 12;\n              return Promise.all(_this.strategy.handleAll({\n                params: {\n                  cacheKey: cacheKey\n                },\n                request: request,\n                event: event\n              }));\n            case 12:\n              _context.next = 5;\n              break;\n            case 14:\n              _context.next = 19;\n              break;\n            case 16:\n              _context.prev = 16;\n              _context.t0 = _context[\"catch\"](3);\n              _iterator2.e(_context.t0);\n            case 19:\n              _context.prev = 19;\n              _iterator2.f();\n              return _context.finish(19);\n            case 22:\n              updatedURLs = installReportPlugin.updatedURLs, notUpdatedURLs = installReportPlugin.notUpdatedURLs;\n              if (process.env.NODE_ENV !== 'production') {\n                printInstallDetails(updatedURLs, notUpdatedURLs);\n              }\n              return _context.abrupt(\"return\", {\n                updatedURLs: updatedURLs,\n                notUpdatedURLs: notUpdatedURLs\n              });\n            case 25:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[3, 16, 19, 22]]);\n      })));\n    }\n    /**\n     * Deletes assets that are no longer present in the current precache manifest.\n     * Call this method from the service worker activate event.\n     *\n     * Note: this method calls `event.waitUntil()` for you, so you do not need\n     * to call it yourself in your event handlers.\n     *\n     * @param {ExtendableEvent} event\n     * @return {Promise<workbox-precaching.CleanupResult>}\n     */\n  }, {\n    key: \"activate\",\n    value: function activate(event) {\n      var _this2 = this;\n      // waitUntil returns Promise<any>\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      return waitUntil(event, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var cache, currentlyCachedRequests, expectedCacheKeys, deletedURLs, _iterator3, _step3, request;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return self.caches.open(_this2.strategy.cacheName);\n            case 2:\n              cache = _context2.sent;\n              _context2.next = 5;\n              return cache.keys();\n            case 5:\n              currentlyCachedRequests = _context2.sent;\n              expectedCacheKeys = new Set(_this2._urlsToCacheKeys.values());\n              deletedURLs = [];\n              _iterator3 = _createForOfIteratorHelper(currentlyCachedRequests);\n              _context2.prev = 9;\n              _iterator3.s();\n            case 11:\n              if ((_step3 = _iterator3.n()).done) {\n                _context2.next = 19;\n                break;\n              }\n              request = _step3.value;\n              if (expectedCacheKeys.has(request.url)) {\n                _context2.next = 17;\n                break;\n              }\n              _context2.next = 16;\n              return cache.delete(request);\n            case 16:\n              deletedURLs.push(request.url);\n            case 17:\n              _context2.next = 11;\n              break;\n            case 19:\n              _context2.next = 24;\n              break;\n            case 21:\n              _context2.prev = 21;\n              _context2.t0 = _context2[\"catch\"](9);\n              _iterator3.e(_context2.t0);\n            case 24:\n              _context2.prev = 24;\n              _iterator3.f();\n              return _context2.finish(24);\n            case 27:\n              if (process.env.NODE_ENV !== 'production') {\n                printCleanupDetails(deletedURLs);\n              }\n              return _context2.abrupt(\"return\", {\n                deletedURLs: deletedURLs\n              });\n            case 29:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, null, [[9, 21, 24, 27]]);\n      })));\n    }\n    /**\n     * Returns a mapping of a precached URL to the corresponding cache key, taking\n     * into account the revision information for the URL.\n     *\n     * @return {Map<string, string>} A URL to cache key mapping.\n     */\n  }, {\n    key: \"getURLsToCacheKeys\",\n    value: function getURLsToCacheKeys() {\n      return this._urlsToCacheKeys;\n    }\n    /**\n     * Returns a list of all the URLs that have been precached by the current\n     * service worker.\n     *\n     * @return {Array<string>} The precached URLs.\n     */\n  }, {\n    key: \"getCachedURLs\",\n    value: function getCachedURLs() {\n      return _toConsumableArray(this._urlsToCacheKeys.keys());\n    }\n    /**\n     * Returns the cache key used for storing a given URL. If that URL is\n     * unversioned, like `/index.html', then the cache key will be the original\n     * URL with a search parameter appended to it.\n     *\n     * @param {string} url A URL whose cache key you want to look up.\n     * @return {string} The versioned URL that corresponds to a cache key\n     * for the original URL, or undefined if that URL isn't precached.\n     */\n  }, {\n    key: \"getCacheKeyForURL\",\n    value: function getCacheKeyForURL(url) {\n      var urlObject = new URL(url, location.href);\n      return this._urlsToCacheKeys.get(urlObject.href);\n    }\n    /**\n     * @param {string} url A cache key whose SRI you want to look up.\n     * @return {string} The subresource integrity associated with the cache key,\n     * or undefined if it's not set.\n     */\n  }, {\n    key: \"getIntegrityForCacheKey\",\n    value: function getIntegrityForCacheKey(cacheKey) {\n      return this._cacheKeysToIntegrities.get(cacheKey);\n    }\n    /**\n     * This acts as a drop-in replacement for\n     * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\n     * with the following differences:\n     *\n     * - It knows what the name of the precache is, and only checks in that cache.\n     * - It allows you to pass in an \"original\" URL without versioning parameters,\n     * and it will automatically look up the correct cache key for the currently\n     * active revision of that URL.\n     *\n     * E.g., `matchPrecache('index.html')` will find the correct precached\n     * response for the currently active service worker, even if the actual cache\n     * key is `'/index.html?__WB_REVISION__=1234abcd'`.\n     *\n     * @param {string|Request} request The key (without revisioning parameters)\n     * to look up in the precache.\n     * @return {Promise<Response|undefined>}\n     */\n  }, {\n    key: \"matchPrecache\",\n    value: function () {\n      var _matchPrecache = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {\n        var url, cacheKey, cache;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              url = request instanceof Request ? request.url : request;\n              cacheKey = this.getCacheKeyForURL(url);\n              if (!cacheKey) {\n                _context3.next = 7;\n                break;\n              }\n              _context3.next = 5;\n              return self.caches.open(this.strategy.cacheName);\n            case 5:\n              cache = _context3.sent;\n              return _context3.abrupt(\"return\", cache.match(cacheKey));\n            case 7:\n              return _context3.abrupt(\"return\", undefined);\n            case 8:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function matchPrecache(_x) {\n        return _matchPrecache.apply(this, arguments);\n      }\n      return matchPrecache;\n    }()\n    /**\n     * Returns a function that looks up `url` in the precache (taking into\n     * account revision information), and returns the corresponding `Response`.\n     *\n     * @param {string} url The precached URL which will be used to lookup the\n     * `Response`.\n     * @return {workbox-routing~handlerCallback}\n     */\n  }, {\n    key: \"createHandlerBoundToURL\",\n    value: function createHandlerBoundToURL(url) {\n      var _this3 = this;\n      var cacheKey = this.getCacheKeyForURL(url);\n      if (!cacheKey) {\n        throw new WorkboxError('non-precached-url', {\n          url: url\n        });\n      }\n      return function (options) {\n        options.request = new Request(url);\n        options.params = Object.assign({\n          cacheKey: cacheKey\n        }, options.params);\n        return _this3.strategy.handle(options);\n      };\n    }\n  }]);\n  return PrecacheController;\n}();\nexport { PrecacheController };","map":{"version":3,"names":["assert","cacheNames","logger","WorkboxError","waitUntil","createCacheKey","PrecacheInstallReportPlugin","PrecacheCacheKeyPlugin","printCleanupDetails","printInstallDetails","PrecacheStrategy","PrecacheController","_ref","arguments","length","undefined","cacheName","_ref$plugins","plugins","_ref$fallbackToNetwor","fallbackToNetwork","_classCallCheck","_urlsToCacheKeys","Map","_urlsToCacheModes","_cacheKeysToIntegrities","_strategy","getPrecacheName","concat","_toConsumableArray","precacheController","install","bind","activate","_createClass","key","get","value","precache","entries","addToCacheList","_installAndActiveListenersAdded","self","addEventListener","process","env","NODE_ENV","isArray","moduleName","className","funcName","paramName","urlsToWarnAbout","_iterator","_createForOfIteratorHelper","_step","s","n","done","entry","push","revision","url","_createCacheKey","cacheKey","cacheMode","has","firstEntry","secondEntry","integrity","set","warningMessage","join","console","warn","err","e","f","event","_this","_asyncToGenerator","_regeneratorRuntime","mark","_callee","installReportPlugin","_iterator2","_step2","_step2$value","request","updatedURLs","notUpdatedURLs","wrap","_callee$","_context","prev","next","strategy","_slicedToArray","Request","cache","credentials","Promise","all","handleAll","params","t0","finish","abrupt","stop","_this2","_callee2","currentlyCachedRequests","expectedCacheKeys","deletedURLs","_iterator3","_step3","_callee2$","_context2","caches","open","sent","keys","Set","values","delete","getURLsToCacheKeys","getCachedURLs","getCacheKeyForURL","urlObject","URL","location","href","getIntegrityForCacheKey","_matchPrecache","_callee3","_callee3$","_context3","match","matchPrecache","_x","apply","createHandlerBoundToURL","_this3","options","Object","assign","handle"],"sources":["/Users/minjeongyeom/Projects/project-wildet/wildet/node_modules/workbox-precaching/PrecacheController.js"],"sourcesContent":["/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { waitUntil } from 'workbox-core/_private/waitUntil.js';\nimport { createCacheKey } from './utils/createCacheKey.js';\nimport { PrecacheInstallReportPlugin } from './utils/PrecacheInstallReportPlugin.js';\nimport { PrecacheCacheKeyPlugin } from './utils/PrecacheCacheKeyPlugin.js';\nimport { printCleanupDetails } from './utils/printCleanupDetails.js';\nimport { printInstallDetails } from './utils/printInstallDetails.js';\nimport { PrecacheStrategy } from './PrecacheStrategy.js';\nimport './_version.js';\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof workbox-precaching\n */\nclass PrecacheController {\n    /**\n     * Create a new PrecacheController.\n     *\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] The cache to use for precaching.\n     * @param {string} [options.plugins] Plugins to use when precaching as well\n     * as responding to fetch events for precached assets.\n     * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n     * get the response from the network if there's a precache miss.\n     */\n    constructor({ cacheName, plugins = [], fallbackToNetwork = true, } = {}) {\n        this._urlsToCacheKeys = new Map();\n        this._urlsToCacheModes = new Map();\n        this._cacheKeysToIntegrities = new Map();\n        this._strategy = new PrecacheStrategy({\n            cacheName: cacheNames.getPrecacheName(cacheName),\n            plugins: [\n                ...plugins,\n                new PrecacheCacheKeyPlugin({ precacheController: this }),\n            ],\n            fallbackToNetwork,\n        });\n        // Bind the install and activate methods to the instance.\n        this.install = this.install.bind(this);\n        this.activate = this.activate.bind(this);\n    }\n    /**\n     * @type {workbox-precaching.PrecacheStrategy} The strategy created by this controller and\n     * used to cache assets and respond to fetch events.\n     */\n    get strategy() {\n        return this._strategy;\n    }\n    /**\n     * Adds items to the precache list, removing any duplicates and\n     * stores the files in the\n     * {@link workbox-core.cacheNames|\"precache cache\"} when the service\n     * worker installs.\n     *\n     * This method can be called multiple times.\n     *\n     * @param {Array<Object|string>} [entries=[]] Array of entries to precache.\n     */\n    precache(entries) {\n        this.addToCacheList(entries);\n        if (!this._installAndActiveListenersAdded) {\n            self.addEventListener('install', this.install);\n            self.addEventListener('activate', this.activate);\n            this._installAndActiveListenersAdded = true;\n        }\n    }\n    /**\n     * This method will add items to the precache list, removing duplicates\n     * and ensuring the information is valid.\n     *\n     * @param {Array<workbox-precaching.PrecacheController.PrecacheEntry|string>} entries\n     *     Array of entries to precache.\n     */\n    addToCacheList(entries) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isArray(entries, {\n                moduleName: 'workbox-precaching',\n                className: 'PrecacheController',\n                funcName: 'addToCacheList',\n                paramName: 'entries',\n            });\n        }\n        const urlsToWarnAbout = [];\n        for (const entry of entries) {\n            // See https://github.com/GoogleChrome/workbox/issues/2259\n            if (typeof entry === 'string') {\n                urlsToWarnAbout.push(entry);\n            }\n            else if (entry && entry.revision === undefined) {\n                urlsToWarnAbout.push(entry.url);\n            }\n            const { cacheKey, url } = createCacheKey(entry);\n            const cacheMode = typeof entry !== 'string' && entry.revision ? 'reload' : 'default';\n            if (this._urlsToCacheKeys.has(url) &&\n                this._urlsToCacheKeys.get(url) !== cacheKey) {\n                throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n                    firstEntry: this._urlsToCacheKeys.get(url),\n                    secondEntry: cacheKey,\n                });\n            }\n            if (typeof entry !== 'string' && entry.integrity) {\n                if (this._cacheKeysToIntegrities.has(cacheKey) &&\n                    this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n                    throw new WorkboxError('add-to-cache-list-conflicting-integrities', {\n                        url,\n                    });\n                }\n                this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n            }\n            this._urlsToCacheKeys.set(url, cacheKey);\n            this._urlsToCacheModes.set(url, cacheMode);\n            if (urlsToWarnAbout.length > 0) {\n                const warningMessage = `Workbox is precaching URLs without revision ` +\n                    `info: ${urlsToWarnAbout.join(', ')}\\nThis is generally NOT safe. ` +\n                    `Learn more at https://bit.ly/wb-precache`;\n                if (process.env.NODE_ENV === 'production') {\n                    // Use console directly to display this warning without bloating\n                    // bundle sizes by pulling in all of the logger codebase in prod.\n                    console.warn(warningMessage);\n                }\n                else {\n                    logger.warn(warningMessage);\n                }\n            }\n        }\n    }\n    /**\n     * Precaches new and updated assets. Call this method from the service worker\n     * install event.\n     *\n     * Note: this method calls `event.waitUntil()` for you, so you do not need\n     * to call it yourself in your event handlers.\n     *\n     * @param {ExtendableEvent} event\n     * @return {Promise<workbox-precaching.InstallResult>}\n     */\n    install(event) {\n        // waitUntil returns Promise<any>\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return waitUntil(event, async () => {\n            const installReportPlugin = new PrecacheInstallReportPlugin();\n            this.strategy.plugins.push(installReportPlugin);\n            // Cache entries one at a time.\n            // See https://github.com/GoogleChrome/workbox/issues/2528\n            for (const [url, cacheKey] of this._urlsToCacheKeys) {\n                const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n                const cacheMode = this._urlsToCacheModes.get(url);\n                const request = new Request(url, {\n                    integrity,\n                    cache: cacheMode,\n                    credentials: 'same-origin',\n                });\n                await Promise.all(this.strategy.handleAll({\n                    params: { cacheKey },\n                    request,\n                    event,\n                }));\n            }\n            const { updatedURLs, notUpdatedURLs } = installReportPlugin;\n            if (process.env.NODE_ENV !== 'production') {\n                printInstallDetails(updatedURLs, notUpdatedURLs);\n            }\n            return { updatedURLs, notUpdatedURLs };\n        });\n    }\n    /**\n     * Deletes assets that are no longer present in the current precache manifest.\n     * Call this method from the service worker activate event.\n     *\n     * Note: this method calls `event.waitUntil()` for you, so you do not need\n     * to call it yourself in your event handlers.\n     *\n     * @param {ExtendableEvent} event\n     * @return {Promise<workbox-precaching.CleanupResult>}\n     */\n    activate(event) {\n        // waitUntil returns Promise<any>\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return waitUntil(event, async () => {\n            const cache = await self.caches.open(this.strategy.cacheName);\n            const currentlyCachedRequests = await cache.keys();\n            const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n            const deletedURLs = [];\n            for (const request of currentlyCachedRequests) {\n                if (!expectedCacheKeys.has(request.url)) {\n                    await cache.delete(request);\n                    deletedURLs.push(request.url);\n                }\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                printCleanupDetails(deletedURLs);\n            }\n            return { deletedURLs };\n        });\n    }\n    /**\n     * Returns a mapping of a precached URL to the corresponding cache key, taking\n     * into account the revision information for the URL.\n     *\n     * @return {Map<string, string>} A URL to cache key mapping.\n     */\n    getURLsToCacheKeys() {\n        return this._urlsToCacheKeys;\n    }\n    /**\n     * Returns a list of all the URLs that have been precached by the current\n     * service worker.\n     *\n     * @return {Array<string>} The precached URLs.\n     */\n    getCachedURLs() {\n        return [...this._urlsToCacheKeys.keys()];\n    }\n    /**\n     * Returns the cache key used for storing a given URL. If that URL is\n     * unversioned, like `/index.html', then the cache key will be the original\n     * URL with a search parameter appended to it.\n     *\n     * @param {string} url A URL whose cache key you want to look up.\n     * @return {string} The versioned URL that corresponds to a cache key\n     * for the original URL, or undefined if that URL isn't precached.\n     */\n    getCacheKeyForURL(url) {\n        const urlObject = new URL(url, location.href);\n        return this._urlsToCacheKeys.get(urlObject.href);\n    }\n    /**\n     * @param {string} url A cache key whose SRI you want to look up.\n     * @return {string} The subresource integrity associated with the cache key,\n     * or undefined if it's not set.\n     */\n    getIntegrityForCacheKey(cacheKey) {\n        return this._cacheKeysToIntegrities.get(cacheKey);\n    }\n    /**\n     * This acts as a drop-in replacement for\n     * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\n     * with the following differences:\n     *\n     * - It knows what the name of the precache is, and only checks in that cache.\n     * - It allows you to pass in an \"original\" URL without versioning parameters,\n     * and it will automatically look up the correct cache key for the currently\n     * active revision of that URL.\n     *\n     * E.g., `matchPrecache('index.html')` will find the correct precached\n     * response for the currently active service worker, even if the actual cache\n     * key is `'/index.html?__WB_REVISION__=1234abcd'`.\n     *\n     * @param {string|Request} request The key (without revisioning parameters)\n     * to look up in the precache.\n     * @return {Promise<Response|undefined>}\n     */\n    async matchPrecache(request) {\n        const url = request instanceof Request ? request.url : request;\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (cacheKey) {\n            const cache = await self.caches.open(this.strategy.cacheName);\n            return cache.match(cacheKey);\n        }\n        return undefined;\n    }\n    /**\n     * Returns a function that looks up `url` in the precache (taking into\n     * account revision information), and returns the corresponding `Response`.\n     *\n     * @param {string} url The precached URL which will be used to lookup the\n     * `Response`.\n     * @return {workbox-routing~handlerCallback}\n     */\n    createHandlerBoundToURL(url) {\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (!cacheKey) {\n            throw new WorkboxError('non-precached-url', { url });\n        }\n        return (options) => {\n            options.request = new Request(url);\n            options.params = Object.assign({ cacheKey }, options.params);\n            return this.strategy.handle(options);\n        };\n    }\n}\nexport { PrecacheController };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
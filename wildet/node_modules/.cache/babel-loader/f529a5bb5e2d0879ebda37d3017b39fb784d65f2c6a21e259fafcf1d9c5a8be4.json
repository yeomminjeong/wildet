{"ast":null,"code":"import _regeneratorRuntime from \"/Users/minjeongyeom/Projects/project-wildet/wildet/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/minjeongyeom/Projects/project-wildet/wildet/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createForOfIteratorHelper from \"/Users/minjeongyeom/Projects/project-wildet/wildet/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/minjeongyeom/Projects/project-wildet/wildet/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/minjeongyeom/Projects/project-wildet/wildet/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/minjeongyeom/Projects/project-wildet/wildet/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheMatchIgnoreParams } from 'workbox-core/_private/cacheMatchIgnoreParams.js';\nimport { Deferred } from 'workbox-core/_private/Deferred.js';\nimport { executeQuotaErrorCallbacks } from 'workbox-core/_private/executeQuotaErrorCallbacks.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { timeout } from 'workbox-core/_private/timeout.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport './_version.js';\nfunction toRequest(input) {\n  return typeof input === 'string' ? new Request(input) : input;\n}\n/**\n * A class created every time a Strategy instance instance calls\n * {@link workbox-strategies.Strategy~handle} or\n * {@link workbox-strategies.Strategy~handleAll} that wraps all fetch and\n * cache actions around plugin callbacks and keeps track of when the strategy\n * is \"done\" (i.e. all added `event.waitUntil()` promises have resolved).\n *\n * @memberof workbox-strategies\n */\nvar StrategyHandler = /*#__PURE__*/function () {\n  /**\n   * Creates a new instance associated with the passed strategy and event\n   * that's handling the request.\n   *\n   * The constructor also initializes the state that will be passed to each of\n   * the plugins handling this request.\n   *\n   * @param {workbox-strategies.Strategy} strategy\n   * @param {Object} options\n   * @param {Request|string} options.request A request to run this strategy for.\n   * @param {ExtendableEvent} options.event The event associated with the\n   *     request.\n   * @param {URL} [options.url]\n   * @param {*} [options.params] The return value from the\n   *     {@link workbox-routing~matchCallback} (if applicable).\n   */\n  function StrategyHandler(strategy, options) {\n    _classCallCheck(this, StrategyHandler);\n    this._cacheKeys = {};\n    /**\n     * The request the strategy is performing (passed to the strategy's\n     * `handle()` or `handleAll()` method).\n     * @name request\n     * @instance\n     * @type {Request}\n     * @memberof workbox-strategies.StrategyHandler\n     */\n    /**\n     * The event associated with this request.\n     * @name event\n     * @instance\n     * @type {ExtendableEvent}\n     * @memberof workbox-strategies.StrategyHandler\n     */\n    /**\n     * A `URL` instance of `request.url` (if passed to the strategy's\n     * `handle()` or `handleAll()` method).\n     * Note: the `url` param will be present if the strategy was invoked\n     * from a workbox `Route` object.\n     * @name url\n     * @instance\n     * @type {URL|undefined}\n     * @memberof workbox-strategies.StrategyHandler\n     */\n    /**\n     * A `param` value (if passed to the strategy's\n     * `handle()` or `handleAll()` method).\n     * Note: the `param` param will be present if the strategy was invoked\n     * from a workbox `Route` object and the\n     * {@link workbox-routing~matchCallback} returned\n     * a truthy value (it will be that value).\n     * @name params\n     * @instance\n     * @type {*|undefined}\n     * @memberof workbox-strategies.StrategyHandler\n     */\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(options.event, ExtendableEvent, {\n        moduleName: 'workbox-strategies',\n        className: 'StrategyHandler',\n        funcName: 'constructor',\n        paramName: 'options.event'\n      });\n    }\n    Object.assign(this, options);\n    this.event = options.event;\n    this._strategy = strategy;\n    this._handlerDeferred = new Deferred();\n    this._extendLifetimePromises = [];\n    // Copy the plugins list (since it's mutable on the strategy),\n    // so any mutations don't affect this handler instance.\n    this._plugins = _toConsumableArray(strategy.plugins);\n    this._pluginStateMap = new Map();\n    var _iterator = _createForOfIteratorHelper(this._plugins),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var plugin = _step.value;\n        this._pluginStateMap.set(plugin, {});\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    this.event.waitUntil(this._handlerDeferred.promise);\n  }\n  /**\n   * Fetches a given request (and invokes any applicable plugin callback\n   * methods) using the `fetchOptions` (for non-navigation requests) and\n   * `plugins` defined on the `Strategy` object.\n   *\n   * The following plugin lifecycle methods are invoked when using this method:\n   * - `requestWillFetch()`\n   * - `fetchDidSucceed()`\n   * - `fetchDidFail()`\n   *\n   * @param {Request|string} input The URL or request to fetch.\n   * @return {Promise<Response>}\n   */\n  _createClass(StrategyHandler, [{\n    key: \"fetch\",\n    value: function (_fetch) {\n      function fetch(_x) {\n        return _fetch.apply(this, arguments);\n      }\n      fetch.toString = function () {\n        return _fetch.toString();\n      };\n      return fetch;\n    }(\n    /*#__PURE__*/\n    function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(input) {\n        var event, request, possiblePreloadResponse, originalRequest, _iterator2, _step2, cb, pluginFilteredRequest, fetchResponse, _iterator3, _step3, callback;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              event = this.event;\n              request = toRequest(input);\n              if (!(request.mode === 'navigate' && event instanceof FetchEvent && event.preloadResponse)) {\n                _context.next = 9;\n                break;\n              }\n              _context.next = 5;\n              return event.preloadResponse;\n            case 5:\n              possiblePreloadResponse = _context.sent;\n              if (!possiblePreloadResponse) {\n                _context.next = 9;\n                break;\n              }\n              if (process.env.NODE_ENV !== 'production') {\n                logger.log(\"Using a preloaded navigation response for \" + \"'\".concat(getFriendlyURL(request.url), \"'\"));\n              }\n              return _context.abrupt(\"return\", possiblePreloadResponse);\n            case 9:\n              // If there is a fetchDidFail plugin, we need to save a clone of the\n              // original request before it's either modified by a requestWillFetch\n              // plugin or before the original request's body is consumed via fetch().\n              originalRequest = this.hasCallback('fetchDidFail') ? request.clone() : null;\n              _context.prev = 10;\n              _iterator2 = _createForOfIteratorHelper(this.iterateCallbacks('requestWillFetch'));\n              _context.prev = 12;\n              _iterator2.s();\n            case 14:\n              if ((_step2 = _iterator2.n()).done) {\n                _context.next = 21;\n                break;\n              }\n              cb = _step2.value;\n              _context.next = 18;\n              return cb({\n                request: request.clone(),\n                event: event\n              });\n            case 18:\n              request = _context.sent;\n            case 19:\n              _context.next = 14;\n              break;\n            case 21:\n              _context.next = 26;\n              break;\n            case 23:\n              _context.prev = 23;\n              _context.t0 = _context[\"catch\"](12);\n              _iterator2.e(_context.t0);\n            case 26:\n              _context.prev = 26;\n              _iterator2.f();\n              return _context.finish(26);\n            case 29:\n              _context.next = 35;\n              break;\n            case 31:\n              _context.prev = 31;\n              _context.t1 = _context[\"catch\"](10);\n              if (!(_context.t1 instanceof Error)) {\n                _context.next = 35;\n                break;\n              }\n              throw new WorkboxError('plugin-error-request-will-fetch', {\n                thrownErrorMessage: _context.t1.message\n              });\n            case 35:\n              // The request can be altered by plugins with `requestWillFetch` making\n              // the original request (most likely from a `fetch` event) different\n              // from the Request we make. Pass both to `fetchDidFail` to aid debugging.\n              pluginFilteredRequest = request.clone();\n              _context.prev = 36;\n              _context.next = 39;\n              return fetch(request, request.mode === 'navigate' ? undefined : this._strategy.fetchOptions);\n            case 39:\n              fetchResponse = _context.sent;\n              if (process.env.NODE_ENV !== 'production') {\n                logger.debug(\"Network request for \" + \"'\".concat(getFriendlyURL(request.url), \"' returned a response with \") + \"status '\".concat(fetchResponse.status, \"'.\"));\n              }\n              _iterator3 = _createForOfIteratorHelper(this.iterateCallbacks('fetchDidSucceed'));\n              _context.prev = 42;\n              _iterator3.s();\n            case 44:\n              if ((_step3 = _iterator3.n()).done) {\n                _context.next = 51;\n                break;\n              }\n              callback = _step3.value;\n              _context.next = 48;\n              return callback({\n                event: event,\n                request: pluginFilteredRequest,\n                response: fetchResponse\n              });\n            case 48:\n              fetchResponse = _context.sent;\n            case 49:\n              _context.next = 44;\n              break;\n            case 51:\n              _context.next = 56;\n              break;\n            case 53:\n              _context.prev = 53;\n              _context.t2 = _context[\"catch\"](42);\n              _iterator3.e(_context.t2);\n            case 56:\n              _context.prev = 56;\n              _iterator3.f();\n              return _context.finish(56);\n            case 59:\n              return _context.abrupt(\"return\", fetchResponse);\n            case 62:\n              _context.prev = 62;\n              _context.t3 = _context[\"catch\"](36);\n              if (process.env.NODE_ENV !== 'production') {\n                logger.log(\"Network request for \" + \"'\".concat(getFriendlyURL(request.url), \"' threw an error.\"), _context.t3);\n              }\n              // `originalRequest` will only exist if a `fetchDidFail` callback\n              // is being used (see above).\n              if (!originalRequest) {\n                _context.next = 68;\n                break;\n              }\n              _context.next = 68;\n              return this.runCallbacks('fetchDidFail', {\n                error: _context.t3,\n                event: event,\n                originalRequest: originalRequest.clone(),\n                request: pluginFilteredRequest.clone()\n              });\n            case 68:\n              throw _context.t3;\n            case 69:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[10, 31], [12, 23, 26, 29], [36, 62], [42, 53, 56, 59]]);\n      }));\n      return function (_x2) {\n        return _ref.apply(this, arguments);\n      };\n    }()\n    /**\n     * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on\n     * the response generated by `this.fetch()`.\n     *\n     * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,\n     * so you do not have to manually call `waitUntil()` on the event.\n     *\n     * @param {Request|string} input The request or URL to fetch and cache.\n     * @return {Promise<Response>}\n     */\n    )\n  }, {\n    key: \"fetchAndCachePut\",\n    value: function () {\n      var _fetchAndCachePut = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(input) {\n        var response, responseClone;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return this.fetch(input);\n            case 2:\n              response = _context2.sent;\n              responseClone = response.clone();\n              void this.waitUntil(this.cachePut(input, responseClone));\n              return _context2.abrupt(\"return\", response);\n            case 6:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function fetchAndCachePut(_x3) {\n        return _fetchAndCachePut.apply(this, arguments);\n      }\n      return fetchAndCachePut;\n    }()\n    /**\n     * Matches a request from the cache (and invokes any applicable plugin\n     * callback methods) using the `cacheName`, `matchOptions`, and `plugins`\n     * defined on the strategy object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - cacheKeyWillByUsed()\n     * - cachedResponseWillByUsed()\n     *\n     * @param {Request|string} key The Request or URL to use as the cache key.\n     * @return {Promise<Response|undefined>} A matching response, if found.\n     */\n  }, {\n    key: \"cacheMatch\",\n    value: function () {\n      var _cacheMatch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(key) {\n        var request, cachedResponse, _this$_strategy, cacheName, matchOptions, effectiveRequest, multiMatchOptions, _iterator4, _step4, callback;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              request = toRequest(key);\n              _this$_strategy = this._strategy, cacheName = _this$_strategy.cacheName, matchOptions = _this$_strategy.matchOptions;\n              _context3.next = 4;\n              return this.getCacheKey(request, 'read');\n            case 4:\n              effectiveRequest = _context3.sent;\n              multiMatchOptions = Object.assign(Object.assign({}, matchOptions), {\n                cacheName: cacheName\n              });\n              _context3.next = 8;\n              return caches.match(effectiveRequest, multiMatchOptions);\n            case 8:\n              cachedResponse = _context3.sent;\n              if (process.env.NODE_ENV !== 'production') {\n                if (cachedResponse) {\n                  logger.debug(\"Found a cached response in '\".concat(cacheName, \"'.\"));\n                } else {\n                  logger.debug(\"No cached response found in '\".concat(cacheName, \"'.\"));\n                }\n              }\n              _iterator4 = _createForOfIteratorHelper(this.iterateCallbacks('cachedResponseWillBeUsed'));\n              _context3.prev = 11;\n              _iterator4.s();\n            case 13:\n              if ((_step4 = _iterator4.n()).done) {\n                _context3.next = 23;\n                break;\n              }\n              callback = _step4.value;\n              _context3.next = 17;\n              return callback({\n                cacheName: cacheName,\n                matchOptions: matchOptions,\n                cachedResponse: cachedResponse,\n                request: effectiveRequest,\n                event: this.event\n              });\n            case 17:\n              _context3.t0 = _context3.sent;\n              if (_context3.t0) {\n                _context3.next = 20;\n                break;\n              }\n              _context3.t0 = undefined;\n            case 20:\n              cachedResponse = _context3.t0;\n            case 21:\n              _context3.next = 13;\n              break;\n            case 23:\n              _context3.next = 28;\n              break;\n            case 25:\n              _context3.prev = 25;\n              _context3.t1 = _context3[\"catch\"](11);\n              _iterator4.e(_context3.t1);\n            case 28:\n              _context3.prev = 28;\n              _iterator4.f();\n              return _context3.finish(28);\n            case 31:\n              return _context3.abrupt(\"return\", cachedResponse);\n            case 32:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[11, 25, 28, 31]]);\n      }));\n      function cacheMatch(_x4) {\n        return _cacheMatch.apply(this, arguments);\n      }\n      return cacheMatch;\n    }()\n    /**\n     * Puts a request/response pair in the cache (and invokes any applicable\n     * plugin callback methods) using the `cacheName` and `plugins` defined on\n     * the strategy object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - cacheKeyWillByUsed()\n     * - cacheWillUpdate()\n     * - cacheDidUpdate()\n     *\n     * @param {Request|string} key The request or URL to use as the cache key.\n     * @param {Response} response The response to cache.\n     * @return {Promise<boolean>} `false` if a cacheWillUpdate caused the response\n     * not be cached, and `true` otherwise.\n     */\n  }, {\n    key: \"cachePut\",\n    value: function () {\n      var _cachePut = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(key, response) {\n        var request, effectiveRequest, vary, responseToCache, _this$_strategy2, cacheName, matchOptions, cache, hasCacheUpdateCallback, oldResponse, _iterator5, _step5, callback;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              request = toRequest(key); // Run in the next task to avoid blocking other cache reads.\n              // https://github.com/w3c/ServiceWorker/issues/1397\n              _context4.next = 3;\n              return timeout(0);\n            case 3:\n              _context4.next = 5;\n              return this.getCacheKey(request, 'write');\n            case 5:\n              effectiveRequest = _context4.sent;\n              if (!(process.env.NODE_ENV !== 'production')) {\n                _context4.next = 11;\n                break;\n              }\n              if (!(effectiveRequest.method && effectiveRequest.method !== 'GET')) {\n                _context4.next = 9;\n                break;\n              }\n              throw new WorkboxError('attempt-to-cache-non-get-request', {\n                url: getFriendlyURL(effectiveRequest.url),\n                method: effectiveRequest.method\n              });\n            case 9:\n              // See https://github.com/GoogleChrome/workbox/issues/2818\n              vary = response.headers.get('Vary');\n              if (vary) {\n                logger.debug(\"The response for \".concat(getFriendlyURL(effectiveRequest.url), \" \") + \"has a 'Vary: \".concat(vary, \"' header. \") + \"Consider setting the {ignoreVary: true} option on your strategy \" + \"to ensure cache matching and deletion works as expected.\");\n              }\n            case 11:\n              if (response) {\n                _context4.next = 14;\n                break;\n              }\n              if (process.env.NODE_ENV !== 'production') {\n                logger.error(\"Cannot cache non-existent response for \" + \"'\".concat(getFriendlyURL(effectiveRequest.url), \"'.\"));\n              }\n              throw new WorkboxError('cache-put-with-no-response', {\n                url: getFriendlyURL(effectiveRequest.url)\n              });\n            case 14:\n              _context4.next = 16;\n              return this._ensureResponseSafeToCache(response);\n            case 16:\n              responseToCache = _context4.sent;\n              if (responseToCache) {\n                _context4.next = 20;\n                break;\n              }\n              if (process.env.NODE_ENV !== 'production') {\n                logger.debug(\"Response '\".concat(getFriendlyURL(effectiveRequest.url), \"' \") + \"will not be cached.\", responseToCache);\n              }\n              return _context4.abrupt(\"return\", false);\n            case 20:\n              _this$_strategy2 = this._strategy, cacheName = _this$_strategy2.cacheName, matchOptions = _this$_strategy2.matchOptions;\n              _context4.next = 23;\n              return self.caches.open(cacheName);\n            case 23:\n              cache = _context4.sent;\n              hasCacheUpdateCallback = this.hasCallback('cacheDidUpdate');\n              if (!hasCacheUpdateCallback) {\n                _context4.next = 31;\n                break;\n              }\n              _context4.next = 28;\n              return cacheMatchIgnoreParams(\n              // TODO(philipwalton): the `__WB_REVISION__` param is a precaching\n              // feature. Consider into ways to only add this behavior if using\n              // precaching.\n              cache, effectiveRequest.clone(), ['__WB_REVISION__'], matchOptions);\n            case 28:\n              _context4.t0 = _context4.sent;\n              _context4.next = 32;\n              break;\n            case 31:\n              _context4.t0 = null;\n            case 32:\n              oldResponse = _context4.t0;\n              if (process.env.NODE_ENV !== 'production') {\n                logger.debug(\"Updating the '\".concat(cacheName, \"' cache with a new Response \") + \"for \".concat(getFriendlyURL(effectiveRequest.url), \".\"));\n              }\n              _context4.prev = 34;\n              _context4.next = 37;\n              return cache.put(effectiveRequest, hasCacheUpdateCallback ? responseToCache.clone() : responseToCache);\n            case 37:\n              _context4.next = 46;\n              break;\n            case 39:\n              _context4.prev = 39;\n              _context4.t1 = _context4[\"catch\"](34);\n              if (!(_context4.t1 instanceof Error)) {\n                _context4.next = 46;\n                break;\n              }\n              if (!(_context4.t1.name === 'QuotaExceededError')) {\n                _context4.next = 45;\n                break;\n              }\n              _context4.next = 45;\n              return executeQuotaErrorCallbacks();\n            case 45:\n              throw _context4.t1;\n            case 46:\n              _iterator5 = _createForOfIteratorHelper(this.iterateCallbacks('cacheDidUpdate'));\n              _context4.prev = 47;\n              _iterator5.s();\n            case 49:\n              if ((_step5 = _iterator5.n()).done) {\n                _context4.next = 55;\n                break;\n              }\n              callback = _step5.value;\n              _context4.next = 53;\n              return callback({\n                cacheName: cacheName,\n                oldResponse: oldResponse,\n                newResponse: responseToCache.clone(),\n                request: effectiveRequest,\n                event: this.event\n              });\n            case 53:\n              _context4.next = 49;\n              break;\n            case 55:\n              _context4.next = 60;\n              break;\n            case 57:\n              _context4.prev = 57;\n              _context4.t2 = _context4[\"catch\"](47);\n              _iterator5.e(_context4.t2);\n            case 60:\n              _context4.prev = 60;\n              _iterator5.f();\n              return _context4.finish(60);\n            case 63:\n              return _context4.abrupt(\"return\", true);\n            case 64:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this, [[34, 39], [47, 57, 60, 63]]);\n      }));\n      function cachePut(_x5, _x6) {\n        return _cachePut.apply(this, arguments);\n      }\n      return cachePut;\n    }()\n    /**\n     * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and\n     * executes any of those callbacks found in sequence. The final `Request`\n     * object returned by the last plugin is treated as the cache key for cache\n     * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have\n     * been registered, the passed request is returned unmodified\n     *\n     * @param {Request} request\n     * @param {string} mode\n     * @return {Promise<Request>}\n     */\n  }, {\n    key: \"getCacheKey\",\n    value: function () {\n      var _getCacheKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(request, mode) {\n        var key, effectiveRequest, _iterator6, _step6, callback;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              key = \"\".concat(request.url, \" | \").concat(mode);\n              if (this._cacheKeys[key]) {\n                _context5.next = 24;\n                break;\n              }\n              effectiveRequest = request;\n              _iterator6 = _createForOfIteratorHelper(this.iterateCallbacks('cacheKeyWillBeUsed'));\n              _context5.prev = 4;\n              _iterator6.s();\n            case 6:\n              if ((_step6 = _iterator6.n()).done) {\n                _context5.next = 15;\n                break;\n              }\n              callback = _step6.value;\n              _context5.t0 = toRequest;\n              _context5.next = 11;\n              return callback({\n                mode: mode,\n                request: effectiveRequest,\n                event: this.event,\n                // params has a type any can't change right now.\n                params: this.params // eslint-disable-line\n              });\n            case 11:\n              _context5.t1 = _context5.sent;\n              effectiveRequest = (0, _context5.t0)(_context5.t1);\n            case 13:\n              _context5.next = 6;\n              break;\n            case 15:\n              _context5.next = 20;\n              break;\n            case 17:\n              _context5.prev = 17;\n              _context5.t2 = _context5[\"catch\"](4);\n              _iterator6.e(_context5.t2);\n            case 20:\n              _context5.prev = 20;\n              _iterator6.f();\n              return _context5.finish(20);\n            case 23:\n              this._cacheKeys[key] = effectiveRequest;\n            case 24:\n              return _context5.abrupt(\"return\", this._cacheKeys[key]);\n            case 25:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this, [[4, 17, 20, 23]]);\n      }));\n      function getCacheKey(_x7, _x8) {\n        return _getCacheKey.apply(this, arguments);\n      }\n      return getCacheKey;\n    }()\n    /**\n     * Returns true if the strategy has at least one plugin with the given\n     * callback.\n     *\n     * @param {string} name The name of the callback to check for.\n     * @return {boolean}\n     */\n  }, {\n    key: \"hasCallback\",\n    value: function hasCallback(name) {\n      var _iterator7 = _createForOfIteratorHelper(this._strategy.plugins),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var plugin = _step7.value;\n          if (name in plugin) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n      return false;\n    }\n    /**\n     * Runs all plugin callbacks matching the given name, in order, passing the\n     * given param object (merged ith the current plugin state) as the only\n     * argument.\n     *\n     * Note: since this method runs all plugins, it's not suitable for cases\n     * where the return value of a callback needs to be applied prior to calling\n     * the next callback. See\n     * {@link workbox-strategies.StrategyHandler#iterateCallbacks}\n     * below for how to handle that case.\n     *\n     * @param {string} name The name of the callback to run within each plugin.\n     * @param {Object} param The object to pass as the first (and only) param\n     *     when executing each callback. This object will be merged with the\n     *     current plugin state prior to callback execution.\n     */\n  }, {\n    key: \"runCallbacks\",\n    value: function () {\n      var _runCallbacks = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(name, param) {\n        var _iterator8, _step8, callback;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _iterator8 = _createForOfIteratorHelper(this.iterateCallbacks(name));\n              _context6.prev = 1;\n              _iterator8.s();\n            case 3:\n              if ((_step8 = _iterator8.n()).done) {\n                _context6.next = 9;\n                break;\n              }\n              callback = _step8.value;\n              _context6.next = 7;\n              return callback(param);\n            case 7:\n              _context6.next = 3;\n              break;\n            case 9:\n              _context6.next = 14;\n              break;\n            case 11:\n              _context6.prev = 11;\n              _context6.t0 = _context6[\"catch\"](1);\n              _iterator8.e(_context6.t0);\n            case 14:\n              _context6.prev = 14;\n              _iterator8.f();\n              return _context6.finish(14);\n            case 17:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this, [[1, 11, 14, 17]]);\n      }));\n      function runCallbacks(_x9, _x10) {\n        return _runCallbacks.apply(this, arguments);\n      }\n      return runCallbacks;\n    }()\n    /**\n     * Accepts a callback and returns an iterable of matching plugin callbacks,\n     * where each callback is wrapped with the current handler state (i.e. when\n     * you call each callback, whatever object parameter you pass it will\n     * be merged with the plugin's current state).\n     *\n     * @param {string} name The name fo the callback to run\n     * @return {Array<Function>}\n     */\n  }, {\n    key: \"iterateCallbacks\",\n    value:\n    /*#__PURE__*/\n    _regeneratorRuntime().mark(function iterateCallbacks(name) {\n      var _this = this;\n      var _iterator9, _step9, _loop;\n      return _regeneratorRuntime().wrap(function iterateCallbacks$(_context8) {\n        while (1) switch (_context8.prev = _context8.next) {\n          case 0:\n            _iterator9 = _createForOfIteratorHelper(this._strategy.plugins);\n            _context8.prev = 1;\n            _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n              var plugin, state, statefulCallback;\n              return _regeneratorRuntime().wrap(function _loop$(_context7) {\n                while (1) switch (_context7.prev = _context7.next) {\n                  case 0:\n                    plugin = _step9.value;\n                    if (!(typeof plugin[name] === 'function')) {\n                      _context7.next = 6;\n                      break;\n                    }\n                    state = _this._pluginStateMap.get(plugin);\n                    statefulCallback = function statefulCallback(param) {\n                      var statefulParam = Object.assign(Object.assign({}, param), {\n                        state: state\n                      });\n                      // TODO(philipwalton): not sure why `any` is needed. It seems like\n                      // this should work with `as WorkboxPluginCallbackParam[C]`.\n                      return plugin[name](statefulParam);\n                    };\n                    _context7.next = 6;\n                    return statefulCallback;\n                  case 6:\n                  case \"end\":\n                    return _context7.stop();\n                }\n              }, _loop);\n            });\n            _iterator9.s();\n          case 4:\n            if ((_step9 = _iterator9.n()).done) {\n              _context8.next = 8;\n              break;\n            }\n            return _context8.delegateYield(_loop(), \"t0\", 6);\n          case 6:\n            _context8.next = 4;\n            break;\n          case 8:\n            _context8.next = 13;\n            break;\n          case 10:\n            _context8.prev = 10;\n            _context8.t1 = _context8[\"catch\"](1);\n            _iterator9.e(_context8.t1);\n          case 13:\n            _context8.prev = 13;\n            _iterator9.f();\n            return _context8.finish(13);\n          case 16:\n          case \"end\":\n            return _context8.stop();\n        }\n      }, iterateCallbacks, this, [[1, 10, 13, 16]]);\n    })\n    /**\n     * Adds a promise to the\n     * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}\n     * of the event event associated with the request being handled (usually a\n     * `FetchEvent`).\n     *\n     * Note: you can await\n     * {@link workbox-strategies.StrategyHandler~doneWaiting}\n     * to know when all added promises have settled.\n     *\n     * @param {Promise} promise A promise to add to the extend lifetime promises\n     *     of the event that triggered the request.\n     */\n  }, {\n    key: \"waitUntil\",\n    value: function waitUntil(promise) {\n      this._extendLifetimePromises.push(promise);\n      return promise;\n    }\n    /**\n     * Returns a promise that resolves once all promises passed to\n     * {@link workbox-strategies.StrategyHandler~waitUntil}\n     * have settled.\n     *\n     * Note: any work done after `doneWaiting()` settles should be manually\n     * passed to an event's `waitUntil()` method (not this handler's\n     * `waitUntil()` method), otherwise the service worker thread my be killed\n     * prior to your work completing.\n     */\n  }, {\n    key: \"doneWaiting\",\n    value: function () {\n      var _doneWaiting = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var promise;\n        return _regeneratorRuntime().wrap(function _callee7$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              if (!(promise = this._extendLifetimePromises.shift())) {\n                _context9.next = 5;\n                break;\n              }\n              _context9.next = 3;\n              return promise;\n            case 3:\n              _context9.next = 0;\n              break;\n            case 5:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee7, this);\n      }));\n      function doneWaiting() {\n        return _doneWaiting.apply(this, arguments);\n      }\n      return doneWaiting;\n    }()\n    /**\n     * Stops running the strategy and immediately resolves any pending\n     * `waitUntil()` promises.\n     */\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._handlerDeferred.resolve(null);\n    }\n    /**\n     * This method will call cacheWillUpdate on the available plugins (or use\n     * status === 200) to determine if the Response is safe and valid to cache.\n     *\n     * @param {Request} options.request\n     * @param {Response} options.response\n     * @return {Promise<Response|undefined>}\n     *\n     * @private\n     */\n  }, {\n    key: \"_ensureResponseSafeToCache\",\n    value: function () {\n      var _ensureResponseSafeToCache2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(response) {\n        var responseToCache, pluginsUsed, _iterator10, _step10, callback;\n        return _regeneratorRuntime().wrap(function _callee8$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              responseToCache = response;\n              pluginsUsed = false;\n              _iterator10 = _createForOfIteratorHelper(this.iterateCallbacks('cacheWillUpdate'));\n              _context10.prev = 3;\n              _iterator10.s();\n            case 5:\n              if ((_step10 = _iterator10.n()).done) {\n                _context10.next = 18;\n                break;\n              }\n              callback = _step10.value;\n              _context10.next = 9;\n              return callback({\n                request: this.request,\n                response: responseToCache,\n                event: this.event\n              });\n            case 9:\n              _context10.t0 = _context10.sent;\n              if (_context10.t0) {\n                _context10.next = 12;\n                break;\n              }\n              _context10.t0 = undefined;\n            case 12:\n              responseToCache = _context10.t0;\n              pluginsUsed = true;\n              if (responseToCache) {\n                _context10.next = 16;\n                break;\n              }\n              return _context10.abrupt(\"break\", 18);\n            case 16:\n              _context10.next = 5;\n              break;\n            case 18:\n              _context10.next = 23;\n              break;\n            case 20:\n              _context10.prev = 20;\n              _context10.t1 = _context10[\"catch\"](3);\n              _iterator10.e(_context10.t1);\n            case 23:\n              _context10.prev = 23;\n              _iterator10.f();\n              return _context10.finish(23);\n            case 26:\n              if (!pluginsUsed) {\n                if (responseToCache && responseToCache.status !== 200) {\n                  responseToCache = undefined;\n                }\n                if (process.env.NODE_ENV !== 'production') {\n                  if (responseToCache) {\n                    if (responseToCache.status !== 200) {\n                      if (responseToCache.status === 0) {\n                        logger.warn(\"The response for '\".concat(this.request.url, \"' \") + \"is an opaque response. The caching strategy that you're \" + \"using will not cache opaque responses by default.\");\n                      } else {\n                        logger.debug(\"The response for '\".concat(this.request.url, \"' \") + \"returned a status code of '\".concat(response.status, \"' and won't \") + \"be cached as a result.\");\n                      }\n                    }\n                  }\n                }\n              }\n              return _context10.abrupt(\"return\", responseToCache);\n            case 28:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee8, this, [[3, 20, 23, 26]]);\n      }));\n      function _ensureResponseSafeToCache(_x11) {\n        return _ensureResponseSafeToCache2.apply(this, arguments);\n      }\n      return _ensureResponseSafeToCache;\n    }()\n  }]);\n  return StrategyHandler;\n}();\nexport { StrategyHandler };","map":{"version":3,"names":["assert","cacheMatchIgnoreParams","Deferred","executeQuotaErrorCallbacks","getFriendlyURL","logger","timeout","WorkboxError","toRequest","input","Request","StrategyHandler","strategy","options","_classCallCheck","_cacheKeys","process","env","NODE_ENV","isInstance","event","ExtendableEvent","moduleName","className","funcName","paramName","Object","assign","_strategy","_handlerDeferred","_extendLifetimePromises","_plugins","_toConsumableArray","plugins","_pluginStateMap","Map","_iterator","_createForOfIteratorHelper","_step","s","n","done","plugin","value","set","err","e","f","waitUntil","promise","_createClass","key","_fetch","fetch","_x","apply","arguments","toString","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","request","possiblePreloadResponse","originalRequest","_iterator2","_step2","cb","pluginFilteredRequest","fetchResponse","_iterator3","_step3","callback","wrap","_callee$","_context","prev","next","mode","FetchEvent","preloadResponse","sent","log","concat","url","abrupt","hasCallback","clone","iterateCallbacks","t0","finish","t1","Error","thrownErrorMessage","message","undefined","fetchOptions","debug","status","response","t2","t3","runCallbacks","error","stop","_x2","_fetchAndCachePut","_callee2","responseClone","_callee2$","_context2","cachePut","fetchAndCachePut","_x3","_cacheMatch","_callee3","cachedResponse","_this$_strategy","cacheName","matchOptions","effectiveRequest","multiMatchOptions","_iterator4","_step4","_callee3$","_context3","getCacheKey","caches","match","cacheMatch","_x4","_cachePut","_callee4","vary","responseToCache","_this$_strategy2","cache","hasCacheUpdateCallback","oldResponse","_iterator5","_step5","_callee4$","_context4","method","headers","get","_ensureResponseSafeToCache","self","open","put","name","newResponse","_x5","_x6","_getCacheKey","_callee5","_iterator6","_step6","_callee5$","_context5","params","_x7","_x8","_iterator7","_step7","_runCallbacks","_callee6","param","_iterator8","_step8","_callee6$","_context6","_x9","_x10","_this","_iterator9","_step9","_loop","iterateCallbacks$","_context8","state","statefulCallback","_loop$","_context7","statefulParam","delegateYield","push","_doneWaiting","_callee7","_callee7$","_context9","shift","doneWaiting","destroy","resolve","_ensureResponseSafeToCache2","_callee8","pluginsUsed","_iterator10","_step10","_callee8$","_context10","warn","_x11"],"sources":["/Users/minjeongyeom/Projects/project-wildet/wildet/node_modules/workbox-strategies/StrategyHandler.js"],"sourcesContent":["/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheMatchIgnoreParams } from 'workbox-core/_private/cacheMatchIgnoreParams.js';\nimport { Deferred } from 'workbox-core/_private/Deferred.js';\nimport { executeQuotaErrorCallbacks } from 'workbox-core/_private/executeQuotaErrorCallbacks.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { timeout } from 'workbox-core/_private/timeout.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport './_version.js';\nfunction toRequest(input) {\n    return typeof input === 'string' ? new Request(input) : input;\n}\n/**\n * A class created every time a Strategy instance instance calls\n * {@link workbox-strategies.Strategy~handle} or\n * {@link workbox-strategies.Strategy~handleAll} that wraps all fetch and\n * cache actions around plugin callbacks and keeps track of when the strategy\n * is \"done\" (i.e. all added `event.waitUntil()` promises have resolved).\n *\n * @memberof workbox-strategies\n */\nclass StrategyHandler {\n    /**\n     * Creates a new instance associated with the passed strategy and event\n     * that's handling the request.\n     *\n     * The constructor also initializes the state that will be passed to each of\n     * the plugins handling this request.\n     *\n     * @param {workbox-strategies.Strategy} strategy\n     * @param {Object} options\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params] The return value from the\n     *     {@link workbox-routing~matchCallback} (if applicable).\n     */\n    constructor(strategy, options) {\n        this._cacheKeys = {};\n        /**\n         * The request the strategy is performing (passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * @name request\n         * @instance\n         * @type {Request}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * The event associated with this request.\n         * @name event\n         * @instance\n         * @type {ExtendableEvent}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * A `URL` instance of `request.url` (if passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * Note: the `url` param will be present if the strategy was invoked\n         * from a workbox `Route` object.\n         * @name url\n         * @instance\n         * @type {URL|undefined}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * A `param` value (if passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * Note: the `param` param will be present if the strategy was invoked\n         * from a workbox `Route` object and the\n         * {@link workbox-routing~matchCallback} returned\n         * a truthy value (it will be that value).\n         * @name params\n         * @instance\n         * @type {*|undefined}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(options.event, ExtendableEvent, {\n                moduleName: 'workbox-strategies',\n                className: 'StrategyHandler',\n                funcName: 'constructor',\n                paramName: 'options.event',\n            });\n        }\n        Object.assign(this, options);\n        this.event = options.event;\n        this._strategy = strategy;\n        this._handlerDeferred = new Deferred();\n        this._extendLifetimePromises = [];\n        // Copy the plugins list (since it's mutable on the strategy),\n        // so any mutations don't affect this handler instance.\n        this._plugins = [...strategy.plugins];\n        this._pluginStateMap = new Map();\n        for (const plugin of this._plugins) {\n            this._pluginStateMap.set(plugin, {});\n        }\n        this.event.waitUntil(this._handlerDeferred.promise);\n    }\n    /**\n     * Fetches a given request (and invokes any applicable plugin callback\n     * methods) using the `fetchOptions` (for non-navigation requests) and\n     * `plugins` defined on the `Strategy` object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - `requestWillFetch()`\n     * - `fetchDidSucceed()`\n     * - `fetchDidFail()`\n     *\n     * @param {Request|string} input The URL or request to fetch.\n     * @return {Promise<Response>}\n     */\n    async fetch(input) {\n        const { event } = this;\n        let request = toRequest(input);\n        if (request.mode === 'navigate' &&\n            event instanceof FetchEvent &&\n            event.preloadResponse) {\n            const possiblePreloadResponse = (await event.preloadResponse);\n            if (possiblePreloadResponse) {\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.log(`Using a preloaded navigation response for ` +\n                        `'${getFriendlyURL(request.url)}'`);\n                }\n                return possiblePreloadResponse;\n            }\n        }\n        // If there is a fetchDidFail plugin, we need to save a clone of the\n        // original request before it's either modified by a requestWillFetch\n        // plugin or before the original request's body is consumed via fetch().\n        const originalRequest = this.hasCallback('fetchDidFail')\n            ? request.clone()\n            : null;\n        try {\n            for (const cb of this.iterateCallbacks('requestWillFetch')) {\n                request = await cb({ request: request.clone(), event });\n            }\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                throw new WorkboxError('plugin-error-request-will-fetch', {\n                    thrownErrorMessage: err.message,\n                });\n            }\n        }\n        // The request can be altered by plugins with `requestWillFetch` making\n        // the original request (most likely from a `fetch` event) different\n        // from the Request we make. Pass both to `fetchDidFail` to aid debugging.\n        const pluginFilteredRequest = request.clone();\n        try {\n            let fetchResponse;\n            // See https://github.com/GoogleChrome/workbox/issues/1796\n            fetchResponse = await fetch(request, request.mode === 'navigate' ? undefined : this._strategy.fetchOptions);\n            if (process.env.NODE_ENV !== 'production') {\n                logger.debug(`Network request for ` +\n                    `'${getFriendlyURL(request.url)}' returned a response with ` +\n                    `status '${fetchResponse.status}'.`);\n            }\n            for (const callback of this.iterateCallbacks('fetchDidSucceed')) {\n                fetchResponse = await callback({\n                    event,\n                    request: pluginFilteredRequest,\n                    response: fetchResponse,\n                });\n            }\n            return fetchResponse;\n        }\n        catch (error) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.log(`Network request for ` +\n                    `'${getFriendlyURL(request.url)}' threw an error.`, error);\n            }\n            // `originalRequest` will only exist if a `fetchDidFail` callback\n            // is being used (see above).\n            if (originalRequest) {\n                await this.runCallbacks('fetchDidFail', {\n                    error: error,\n                    event,\n                    originalRequest: originalRequest.clone(),\n                    request: pluginFilteredRequest.clone(),\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on\n     * the response generated by `this.fetch()`.\n     *\n     * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,\n     * so you do not have to manually call `waitUntil()` on the event.\n     *\n     * @param {Request|string} input The request or URL to fetch and cache.\n     * @return {Promise<Response>}\n     */\n    async fetchAndCachePut(input) {\n        const response = await this.fetch(input);\n        const responseClone = response.clone();\n        void this.waitUntil(this.cachePut(input, responseClone));\n        return response;\n    }\n    /**\n     * Matches a request from the cache (and invokes any applicable plugin\n     * callback methods) using the `cacheName`, `matchOptions`, and `plugins`\n     * defined on the strategy object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - cacheKeyWillByUsed()\n     * - cachedResponseWillByUsed()\n     *\n     * @param {Request|string} key The Request or URL to use as the cache key.\n     * @return {Promise<Response|undefined>} A matching response, if found.\n     */\n    async cacheMatch(key) {\n        const request = toRequest(key);\n        let cachedResponse;\n        const { cacheName, matchOptions } = this._strategy;\n        const effectiveRequest = await this.getCacheKey(request, 'read');\n        const multiMatchOptions = Object.assign(Object.assign({}, matchOptions), { cacheName });\n        cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);\n        if (process.env.NODE_ENV !== 'production') {\n            if (cachedResponse) {\n                logger.debug(`Found a cached response in '${cacheName}'.`);\n            }\n            else {\n                logger.debug(`No cached response found in '${cacheName}'.`);\n            }\n        }\n        for (const callback of this.iterateCallbacks('cachedResponseWillBeUsed')) {\n            cachedResponse =\n                (await callback({\n                    cacheName,\n                    matchOptions,\n                    cachedResponse,\n                    request: effectiveRequest,\n                    event: this.event,\n                })) || undefined;\n        }\n        return cachedResponse;\n    }\n    /**\n     * Puts a request/response pair in the cache (and invokes any applicable\n     * plugin callback methods) using the `cacheName` and `plugins` defined on\n     * the strategy object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - cacheKeyWillByUsed()\n     * - cacheWillUpdate()\n     * - cacheDidUpdate()\n     *\n     * @param {Request|string} key The request or URL to use as the cache key.\n     * @param {Response} response The response to cache.\n     * @return {Promise<boolean>} `false` if a cacheWillUpdate caused the response\n     * not be cached, and `true` otherwise.\n     */\n    async cachePut(key, response) {\n        const request = toRequest(key);\n        // Run in the next task to avoid blocking other cache reads.\n        // https://github.com/w3c/ServiceWorker/issues/1397\n        await timeout(0);\n        const effectiveRequest = await this.getCacheKey(request, 'write');\n        if (process.env.NODE_ENV !== 'production') {\n            if (effectiveRequest.method && effectiveRequest.method !== 'GET') {\n                throw new WorkboxError('attempt-to-cache-non-get-request', {\n                    url: getFriendlyURL(effectiveRequest.url),\n                    method: effectiveRequest.method,\n                });\n            }\n            // See https://github.com/GoogleChrome/workbox/issues/2818\n            const vary = response.headers.get('Vary');\n            if (vary) {\n                logger.debug(`The response for ${getFriendlyURL(effectiveRequest.url)} ` +\n                    `has a 'Vary: ${vary}' header. ` +\n                    `Consider setting the {ignoreVary: true} option on your strategy ` +\n                    `to ensure cache matching and deletion works as expected.`);\n            }\n        }\n        if (!response) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.error(`Cannot cache non-existent response for ` +\n                    `'${getFriendlyURL(effectiveRequest.url)}'.`);\n            }\n            throw new WorkboxError('cache-put-with-no-response', {\n                url: getFriendlyURL(effectiveRequest.url),\n            });\n        }\n        const responseToCache = await this._ensureResponseSafeToCache(response);\n        if (!responseToCache) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' ` +\n                    `will not be cached.`, responseToCache);\n            }\n            return false;\n        }\n        const { cacheName, matchOptions } = this._strategy;\n        const cache = await self.caches.open(cacheName);\n        const hasCacheUpdateCallback = this.hasCallback('cacheDidUpdate');\n        const oldResponse = hasCacheUpdateCallback\n            ? await cacheMatchIgnoreParams(\n            // TODO(philipwalton): the `__WB_REVISION__` param is a precaching\n            // feature. Consider into ways to only add this behavior if using\n            // precaching.\n            cache, effectiveRequest.clone(), ['__WB_REVISION__'], matchOptions)\n            : null;\n        if (process.env.NODE_ENV !== 'production') {\n            logger.debug(`Updating the '${cacheName}' cache with a new Response ` +\n                `for ${getFriendlyURL(effectiveRequest.url)}.`);\n        }\n        try {\n            await cache.put(effectiveRequest, hasCacheUpdateCallback ? responseToCache.clone() : responseToCache);\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n                if (error.name === 'QuotaExceededError') {\n                    await executeQuotaErrorCallbacks();\n                }\n                throw error;\n            }\n        }\n        for (const callback of this.iterateCallbacks('cacheDidUpdate')) {\n            await callback({\n                cacheName,\n                oldResponse,\n                newResponse: responseToCache.clone(),\n                request: effectiveRequest,\n                event: this.event,\n            });\n        }\n        return true;\n    }\n    /**\n     * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and\n     * executes any of those callbacks found in sequence. The final `Request`\n     * object returned by the last plugin is treated as the cache key for cache\n     * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have\n     * been registered, the passed request is returned unmodified\n     *\n     * @param {Request} request\n     * @param {string} mode\n     * @return {Promise<Request>}\n     */\n    async getCacheKey(request, mode) {\n        const key = `${request.url} | ${mode}`;\n        if (!this._cacheKeys[key]) {\n            let effectiveRequest = request;\n            for (const callback of this.iterateCallbacks('cacheKeyWillBeUsed')) {\n                effectiveRequest = toRequest(await callback({\n                    mode,\n                    request: effectiveRequest,\n                    event: this.event,\n                    // params has a type any can't change right now.\n                    params: this.params, // eslint-disable-line\n                }));\n            }\n            this._cacheKeys[key] = effectiveRequest;\n        }\n        return this._cacheKeys[key];\n    }\n    /**\n     * Returns true if the strategy has at least one plugin with the given\n     * callback.\n     *\n     * @param {string} name The name of the callback to check for.\n     * @return {boolean}\n     */\n    hasCallback(name) {\n        for (const plugin of this._strategy.plugins) {\n            if (name in plugin) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Runs all plugin callbacks matching the given name, in order, passing the\n     * given param object (merged ith the current plugin state) as the only\n     * argument.\n     *\n     * Note: since this method runs all plugins, it's not suitable for cases\n     * where the return value of a callback needs to be applied prior to calling\n     * the next callback. See\n     * {@link workbox-strategies.StrategyHandler#iterateCallbacks}\n     * below for how to handle that case.\n     *\n     * @param {string} name The name of the callback to run within each plugin.\n     * @param {Object} param The object to pass as the first (and only) param\n     *     when executing each callback. This object will be merged with the\n     *     current plugin state prior to callback execution.\n     */\n    async runCallbacks(name, param) {\n        for (const callback of this.iterateCallbacks(name)) {\n            // TODO(philipwalton): not sure why `any` is needed. It seems like\n            // this should work with `as WorkboxPluginCallbackParam[C]`.\n            await callback(param);\n        }\n    }\n    /**\n     * Accepts a callback and returns an iterable of matching plugin callbacks,\n     * where each callback is wrapped with the current handler state (i.e. when\n     * you call each callback, whatever object parameter you pass it will\n     * be merged with the plugin's current state).\n     *\n     * @param {string} name The name fo the callback to run\n     * @return {Array<Function>}\n     */\n    *iterateCallbacks(name) {\n        for (const plugin of this._strategy.plugins) {\n            if (typeof plugin[name] === 'function') {\n                const state = this._pluginStateMap.get(plugin);\n                const statefulCallback = (param) => {\n                    const statefulParam = Object.assign(Object.assign({}, param), { state });\n                    // TODO(philipwalton): not sure why `any` is needed. It seems like\n                    // this should work with `as WorkboxPluginCallbackParam[C]`.\n                    return plugin[name](statefulParam);\n                };\n                yield statefulCallback;\n            }\n        }\n    }\n    /**\n     * Adds a promise to the\n     * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}\n     * of the event event associated with the request being handled (usually a\n     * `FetchEvent`).\n     *\n     * Note: you can await\n     * {@link workbox-strategies.StrategyHandler~doneWaiting}\n     * to know when all added promises have settled.\n     *\n     * @param {Promise} promise A promise to add to the extend lifetime promises\n     *     of the event that triggered the request.\n     */\n    waitUntil(promise) {\n        this._extendLifetimePromises.push(promise);\n        return promise;\n    }\n    /**\n     * Returns a promise that resolves once all promises passed to\n     * {@link workbox-strategies.StrategyHandler~waitUntil}\n     * have settled.\n     *\n     * Note: any work done after `doneWaiting()` settles should be manually\n     * passed to an event's `waitUntil()` method (not this handler's\n     * `waitUntil()` method), otherwise the service worker thread my be killed\n     * prior to your work completing.\n     */\n    async doneWaiting() {\n        let promise;\n        while ((promise = this._extendLifetimePromises.shift())) {\n            await promise;\n        }\n    }\n    /**\n     * Stops running the strategy and immediately resolves any pending\n     * `waitUntil()` promises.\n     */\n    destroy() {\n        this._handlerDeferred.resolve(null);\n    }\n    /**\n     * This method will call cacheWillUpdate on the available plugins (or use\n     * status === 200) to determine if the Response is safe and valid to cache.\n     *\n     * @param {Request} options.request\n     * @param {Response} options.response\n     * @return {Promise<Response|undefined>}\n     *\n     * @private\n     */\n    async _ensureResponseSafeToCache(response) {\n        let responseToCache = response;\n        let pluginsUsed = false;\n        for (const callback of this.iterateCallbacks('cacheWillUpdate')) {\n            responseToCache =\n                (await callback({\n                    request: this.request,\n                    response: responseToCache,\n                    event: this.event,\n                })) || undefined;\n            pluginsUsed = true;\n            if (!responseToCache) {\n                break;\n            }\n        }\n        if (!pluginsUsed) {\n            if (responseToCache && responseToCache.status !== 200) {\n                responseToCache = undefined;\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                if (responseToCache) {\n                    if (responseToCache.status !== 200) {\n                        if (responseToCache.status === 0) {\n                            logger.warn(`The response for '${this.request.url}' ` +\n                                `is an opaque response. The caching strategy that you're ` +\n                                `using will not cache opaque responses by default.`);\n                        }\n                        else {\n                            logger.debug(`The response for '${this.request.url}' ` +\n                                `returned a status code of '${response.status}' and won't ` +\n                                `be cached as a result.`);\n                        }\n                    }\n                }\n            }\n        }\n        return responseToCache;\n    }\n}\nexport { StrategyHandler };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
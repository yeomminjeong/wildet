{"ast":null,"code":"import _regeneratorRuntime from \"/Users/minjeongyeom/Projects/project-wildet/wildet/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/minjeongyeom/Projects/project-wildet/wildet/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { timeout } from './timeout.js';\nimport '../_version.js';\nvar MAX_RETRY_TIME = 2000;\n/**\n * Returns a promise that resolves to a window client matching the passed\n * `resultingClientId`. For browsers that don't support `resultingClientId`\n * or if waiting for the resulting client to apper takes too long, resolve to\n * `undefined`.\n *\n * @param {string} [resultingClientId]\n * @return {Promise<Client|undefined>}\n * @private\n */\nexport function resultingClientExists(_x) {\n  return _resultingClientExists.apply(this, arguments);\n}\nfunction _resultingClientExists() {\n  _resultingClientExists = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(resultingClientId) {\n    var existingWindows, existingWindowIds, resultingWindow, startTime;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          if (resultingClientId) {\n            _context.next = 2;\n            break;\n          }\n          return _context.abrupt(\"return\");\n        case 2:\n          _context.next = 4;\n          return self.clients.matchAll({\n            type: 'window'\n          });\n        case 4:\n          existingWindows = _context.sent;\n          existingWindowIds = new Set(existingWindows.map(function (w) {\n            return w.id;\n          }));\n          startTime = performance.now(); // Only wait up to `MAX_RETRY_TIME` to find a matching client.\n        case 7:\n          if (!(performance.now() - startTime < MAX_RETRY_TIME)) {\n            _context.next = 18;\n            break;\n          }\n          _context.next = 10;\n          return self.clients.matchAll({\n            type: 'window'\n          });\n        case 10:\n          existingWindows = _context.sent;\n          resultingWindow = existingWindows.find(function (w) {\n            if (resultingClientId) {\n              // If we have a `resultingClientId`, we can match on that.\n              return w.id === resultingClientId;\n            } else {\n              // Otherwise match on finding a window not in `existingWindowIds`.\n              return !existingWindowIds.has(w.id);\n            }\n          });\n          if (!resultingWindow) {\n            _context.next = 14;\n            break;\n          }\n          return _context.abrupt(\"break\", 18);\n        case 14:\n          _context.next = 16;\n          return timeout(100);\n        case 16:\n          _context.next = 7;\n          break;\n        case 18:\n          return _context.abrupt(\"return\", resultingWindow);\n        case 19:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _resultingClientExists.apply(this, arguments);\n}","map":{"version":3,"names":["timeout","MAX_RETRY_TIME","resultingClientExists","_x","_resultingClientExists","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","resultingClientId","existingWindows","existingWindowIds","resultingWindow","startTime","wrap","_callee$","_context","prev","next","abrupt","self","clients","matchAll","type","sent","Set","map","w","id","performance","now","find","has","stop"],"sources":["/Users/minjeongyeom/Projects/project-wildet/wildet/node_modules/workbox-core/_private/resultingClientExists.js"],"sourcesContent":["/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { timeout } from './timeout.js';\nimport '../_version.js';\nconst MAX_RETRY_TIME = 2000;\n/**\n * Returns a promise that resolves to a window client matching the passed\n * `resultingClientId`. For browsers that don't support `resultingClientId`\n * or if waiting for the resulting client to apper takes too long, resolve to\n * `undefined`.\n *\n * @param {string} [resultingClientId]\n * @return {Promise<Client|undefined>}\n * @private\n */\nexport async function resultingClientExists(resultingClientId) {\n    if (!resultingClientId) {\n        return;\n    }\n    let existingWindows = await self.clients.matchAll({ type: 'window' });\n    const existingWindowIds = new Set(existingWindows.map((w) => w.id));\n    let resultingWindow;\n    const startTime = performance.now();\n    // Only wait up to `MAX_RETRY_TIME` to find a matching client.\n    while (performance.now() - startTime < MAX_RETRY_TIME) {\n        existingWindows = await self.clients.matchAll({ type: 'window' });\n        resultingWindow = existingWindows.find((w) => {\n            if (resultingClientId) {\n                // If we have a `resultingClientId`, we can match on that.\n                return w.id === resultingClientId;\n            }\n            else {\n                // Otherwise match on finding a window not in `existingWindowIds`.\n                return !existingWindowIds.has(w.id);\n            }\n        });\n        if (resultingWindow) {\n            break;\n        }\n        // Sleep for 100ms and retry.\n        await timeout(100);\n    }\n    return resultingWindow;\n}\n"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,OAAO,QAAQ,cAAc;AACtC,OAAO,gBAAgB;AACvB,IAAMC,cAAc,GAAG,IAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAsBC,qBAAqBA,CAAAC,EAAA;EAAA,OAAAC,sBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AA4B1C,SAAAF,uBAAA;EAAAA,sBAAA,GAAAG,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CA5BM,SAAAC,QAAqCC,iBAAiB;IAAA,IAAAC,eAAA,EAAAC,iBAAA,EAAAC,eAAA,EAAAC,SAAA;IAAA,OAAAP,mBAAA,GAAAQ,IAAA,UAAAC,SAAAC,QAAA;MAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;QAAA;UAAA,IACpDT,iBAAiB;YAAAO,QAAA,CAAAE,IAAA;YAAA;UAAA;UAAA,OAAAF,QAAA,CAAAG,MAAA;QAAA;UAAAH,QAAA,CAAAE,IAAA;UAAA,OAGME,IAAI,CAACC,OAAO,CAACC,QAAQ,CAAC;YAAEC,IAAI,EAAE;UAAS,CAAC,CAAC;QAAA;UAAjEb,eAAe,GAAAM,QAAA,CAAAQ,IAAA;UACbb,iBAAiB,GAAG,IAAIc,GAAG,CAACf,eAAe,CAACgB,GAAG,CAAC,UAACC,CAAC;YAAA,OAAKA,CAAC,CAACC,EAAE;UAAA,EAAC,CAAC;UAE7Df,SAAS,GAAGgB,WAAW,CAACC,GAAG,EAAE,EACnC;QAAA;UAAA,MACOD,WAAW,CAACC,GAAG,EAAE,GAAGjB,SAAS,GAAGd,cAAc;YAAAiB,QAAA,CAAAE,IAAA;YAAA;UAAA;UAAAF,QAAA,CAAAE,IAAA;UAAA,OACzBE,IAAI,CAACC,OAAO,CAACC,QAAQ,CAAC;YAAEC,IAAI,EAAE;UAAS,CAAC,CAAC;QAAA;UAAjEb,eAAe,GAAAM,QAAA,CAAAQ,IAAA;UACfZ,eAAe,GAAGF,eAAe,CAACqB,IAAI,CAAC,UAACJ,CAAC,EAAK;YAC1C,IAAIlB,iBAAiB,EAAE;cACnB;cACA,OAAOkB,CAAC,CAACC,EAAE,KAAKnB,iBAAiB;YACrC,CAAC,MACI;cACD;cACA,OAAO,CAACE,iBAAiB,CAACqB,GAAG,CAACL,CAAC,CAACC,EAAE,CAAC;YACvC;UACJ,CAAC,CAAC;UAAC,KACChB,eAAe;YAAAI,QAAA,CAAAE,IAAA;YAAA;UAAA;UAAA,OAAAF,QAAA,CAAAG,MAAA;QAAA;UAAAH,QAAA,CAAAE,IAAA;UAAA,OAIbpB,OAAO,CAAC,GAAG,CAAC;QAAA;UAAAkB,QAAA,CAAAE,IAAA;UAAA;QAAA;UAAA,OAAAF,QAAA,CAAAG,MAAA,WAEfP,eAAe;QAAA;QAAA;UAAA,OAAAI,QAAA,CAAAiB,IAAA;MAAA;IAAA,GAAAzB,OAAA;EAAA,CACzB;EAAA,OAAAN,sBAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}
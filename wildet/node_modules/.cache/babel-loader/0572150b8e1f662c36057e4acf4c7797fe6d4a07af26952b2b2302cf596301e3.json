{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { convertToTensor } from '../tensor_util_env';\nimport { parseAxisParam } from '../util';\nimport { abs } from './abs';\nimport * as axis_util from './axis_util';\nimport { max } from './max';\nimport { min } from './min';\nimport { op } from './operation';\nimport { pow } from './pow';\nimport { reshape } from './reshape';\nimport { scalar } from './scalar';\nimport { sqrt } from './sqrt';\nimport { square } from './square';\nimport { sum } from './sum';\n/**\n * Computes the norm of scalar, vectors, and matrices.\n * This function can compute several different vector norms (the 1-norm, the\n * Euclidean or 2-norm, the inf-norm, and in general the p-norm for p > 0)\n * and matrix norms (Frobenius, 1-norm, and inf-norm).\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n *\n * x.norm().print();  // or tf.norm(x)\n * ```\n *\n * @param x The input array.\n * @param ord Optional. Order of the norm. Supported norm types are\n * following:\n *\n *  | ord        | norm for matrices         | norm for vectors\n *  |------------|---------------------------|---------------------\n *  |'euclidean' |Frobenius norm             |2-norm\n *  |'fro'       |Frobenius norm\t           |\n *  |Infinity    |max(sum(abs(x), axis=1))   |max(abs(x))\n *  |-Infinity   |min(sum(abs(x), axis=1))   |min(abs(x))\n *  |1           |max(sum(abs(x), axis=0))   |sum(abs(x))\n *  |2           |                           |sum(abs(x)^2)^(1/2)\n *\n * @param axis Optional. If axis is null (the default), the input is\n * considered a vector and a single vector norm is computed over the entire\n * set of values in the Tensor, i.e. norm(x, ord) is equivalent\n * to norm(x.reshape([-1]), ord). If axis is an integer, the input\n * is considered a batch of vectors, and axis determines the axis in x\n * over which to compute vector norms. If axis is a 2-tuple of integer it is\n * considered a batch of matrices and axis determines the axes in NDArray\n * over which to compute a matrix norm.\n * @param keepDims Optional. If true, the norm has the same dimensionality\n * as the input.\n *\n * @doc {heading: 'Operations', subheading: 'Matrices'}\n */\nfunction norm_(x) {\n  let ord = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'euclidean';\n  let axis = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let keepDims = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  x = convertToTensor(x, 'x', 'norm');\n  const norm = normImpl(x, ord, axis);\n  let keepDimsShape = norm.shape;\n  if (keepDims) {\n    const axes = parseAxisParam(axis, x.shape);\n    keepDimsShape = axis_util.expandShapeToKeepDim(norm.shape, axes);\n  }\n  return reshape(norm, keepDimsShape);\n}\nfunction normImpl(x, p) {\n  let axis = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (x.rank === 0) {\n    return abs(x);\n  }\n  // consider vector when no axis is specified\n  if (x.rank !== 1 && axis === null) {\n    return normImpl(reshape(x, [-1]), p, axis);\n  }\n  // vector\n  if (x.rank === 1 || typeof axis === 'number' || Array.isArray(axis) && axis.length === 1) {\n    if (p === 1) {\n      return sum(abs(x), axis);\n    }\n    if (p === Infinity) {\n      return max(abs(x), axis);\n    }\n    if (p === -Infinity) {\n      return min(abs(x), axis);\n    }\n    if (p === 'euclidean' || p === 2) {\n      // norm(x, 2) = sum(abs(xi) ^ 2) ^ 1/2\n      return sqrt(sum(pow(abs(x), scalar(2, 'int32')), axis));\n    }\n    throw new Error(`Error in norm: invalid ord value: ${p}`);\n  }\n  // matrix (assumption axis[0] < axis[1])\n  if (Array.isArray(axis) && axis.length === 2) {\n    if (p === 1) {\n      return max(sum(abs(x), axis[0]), axis[1] - 1);\n    }\n    if (p === Infinity) {\n      return max(sum(abs(x), axis[1]), axis[0]);\n    }\n    if (p === -Infinity) {\n      return min(sum(abs(x), axis[1]), axis[0]);\n    }\n    if (p === 'fro' || p === 'euclidean') {\n      // norm(x) = sqrt(sum(pow(x, 2)))\n      return sqrt(sum(square(x), axis));\n    }\n    throw new Error(`Error in norm: invalid ord value: ${p}`);\n  }\n  throw new Error(`Error in norm: invalid axis: ${axis}`);\n}\nexport const norm = /* @__PURE__ */op({\n  norm_\n});","map":{"version":3,"names":["convertToTensor","parseAxisParam","abs","axis_util","max","min","op","pow","reshape","scalar","sqrt","square","sum","norm_","x","ord","arguments","length","undefined","axis","keepDims","norm","normImpl","keepDimsShape","shape","axes","expandShapeToKeepDim","p","rank","Array","isArray","Infinity","Error"],"sources":["/Users/minjeongyeom/Projects/project-wildet/tfjs-core/src/ops/norm.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {parseAxisParam} from '../util';\n\nimport {abs} from './abs';\nimport * as axis_util from './axis_util';\nimport {max} from './max';\nimport {min} from './min';\nimport {op} from './operation';\nimport {pow} from './pow';\nimport {reshape} from './reshape';\nimport {scalar} from './scalar';\nimport {sqrt} from './sqrt';\nimport {square} from './square';\nimport {sum} from './sum';\n\n/**\n * Computes the norm of scalar, vectors, and matrices.\n * This function can compute several different vector norms (the 1-norm, the\n * Euclidean or 2-norm, the inf-norm, and in general the p-norm for p > 0)\n * and matrix norms (Frobenius, 1-norm, and inf-norm).\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n *\n * x.norm().print();  // or tf.norm(x)\n * ```\n *\n * @param x The input array.\n * @param ord Optional. Order of the norm. Supported norm types are\n * following:\n *\n *  | ord        | norm for matrices         | norm for vectors\n *  |------------|---------------------------|---------------------\n *  |'euclidean' |Frobenius norm             |2-norm\n *  |'fro'       |Frobenius norm\t           |\n *  |Infinity    |max(sum(abs(x), axis=1))   |max(abs(x))\n *  |-Infinity   |min(sum(abs(x), axis=1))   |min(abs(x))\n *  |1           |max(sum(abs(x), axis=0))   |sum(abs(x))\n *  |2           |                           |sum(abs(x)^2)^(1/2)\n *\n * @param axis Optional. If axis is null (the default), the input is\n * considered a vector and a single vector norm is computed over the entire\n * set of values in the Tensor, i.e. norm(x, ord) is equivalent\n * to norm(x.reshape([-1]), ord). If axis is an integer, the input\n * is considered a batch of vectors, and axis determines the axis in x\n * over which to compute vector norms. If axis is a 2-tuple of integer it is\n * considered a batch of matrices and axis determines the axes in NDArray\n * over which to compute a matrix norm.\n * @param keepDims Optional. If true, the norm has the same dimensionality\n * as the input.\n *\n * @doc {heading: 'Operations', subheading: 'Matrices'}\n */\nfunction norm_(\n    x: Tensor|TensorLike, ord: number|'euclidean'|'fro' = 'euclidean',\n    axis: number|number[] = null, keepDims = false): Tensor {\n  x = convertToTensor(x, 'x', 'norm');\n\n  const norm = normImpl(x, ord, axis);\n  let keepDimsShape = norm.shape;\n  if (keepDims) {\n    const axes = parseAxisParam(axis, x.shape);\n    keepDimsShape = axis_util.expandShapeToKeepDim(norm.shape, axes);\n  }\n  return reshape(norm, keepDimsShape);\n}\n\nfunction normImpl(\n    x: Tensor, p: number|string, axis: number|number[] = null): Tensor {\n  if (x.rank === 0) {\n    return abs(x);\n  }\n\n  // consider vector when no axis is specified\n  if (x.rank !== 1 && axis === null) {\n    return normImpl(reshape(x, [-1]), p, axis);\n  }\n\n  // vector\n  if (x.rank === 1 || typeof axis === 'number' ||\n      Array.isArray(axis) && axis.length === 1) {\n    if (p === 1) {\n      return sum(abs(x), axis);\n    }\n    if (p === Infinity) {\n      return max(abs(x), axis);\n    }\n    if (p === -Infinity) {\n      return min(abs(x), axis);\n    }\n    if (p === 'euclidean' || p === 2) {\n      // norm(x, 2) = sum(abs(xi) ^ 2) ^ 1/2\n      return sqrt(sum(pow(abs(x), scalar(2, 'int32')), axis));\n    }\n\n    throw new Error(`Error in norm: invalid ord value: ${p}`);\n  }\n\n  // matrix (assumption axis[0] < axis[1])\n  if (Array.isArray(axis) && axis.length === 2) {\n    if (p === 1) {\n      return max(sum(abs(x), axis[0]), axis[1] - 1);\n    }\n    if (p === Infinity) {\n      return max(sum(abs(x), axis[1]), axis[0]);\n    }\n    if (p === -Infinity) {\n      return min(sum(abs(x), axis[1]), axis[0]);\n    }\n    if (p === 'fro' || p === 'euclidean') {\n      // norm(x) = sqrt(sum(pow(x, 2)))\n      return sqrt(sum(square(x), axis));\n    }\n\n    throw new Error(`Error in norm: invalid ord value: ${p}`);\n  }\n\n  throw new Error(`Error in norm: invalid axis: ${axis}`);\n}\n\nexport const norm = /* @__PURE__ */ op({norm_});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
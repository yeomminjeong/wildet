{"ast":null,"code":"import * as util from '../util';\n/**\n * Wraps a list of ArrayBuffers into a `slice()`-able object without allocating\n * a large ArrayBuffer.\n *\n * Allocating large ArrayBuffers (~2GB) can be unstable on Chrome. TFJS loads\n * its weights as a list of (usually) 4MB ArrayBuffers and then slices the\n * weight tensors out of them. For small models, it's safe to concatenate all\n * the weight buffers into a single ArrayBuffer and then slice the weight\n * tensors out of it, but for large models, a different approach is needed.\n */\nexport class CompositeArrayBuffer {\n  constructor(buffers) {\n    this.shards = [];\n    this.previousShardIndex = 0;\n    // Normalize the `buffers` input to be `ArrayBuffer[]`.\n    if (!(buffers instanceof Array)) {\n      buffers = [buffers];\n    }\n    buffers = buffers.map(bufferOrTypedArray => {\n      if (util.isTypedArray(bufferOrTypedArray)) {\n        return bufferOrTypedArray.buffer;\n      }\n      return bufferOrTypedArray;\n    });\n    // Skip setting up shards if there are no buffers.\n    if (buffers.length === 0) {\n      return;\n    }\n    this.bufferUniformSize = buffers[0].byteLength;\n    let start = 0;\n    for (let i = 0; i < buffers.length; i++) {\n      const buffer = buffers[i];\n      // Check that all buffers except the last one have the same length.\n      if (i !== buffers.length - 1 && buffer.byteLength !== this.bufferUniformSize) {\n        // Unset the buffer uniform size, since the buffer sizes are not\n        // uniform.\n        this.bufferUniformSize = undefined;\n      }\n      // Create the shards, including their start and end points.\n      const end = start + buffer.byteLength;\n      this.shards.push({\n        buffer,\n        start,\n        end\n      });\n      start = end;\n    }\n    // Set the byteLenghth\n    if (this.shards.length === 0) {\n      this.byteLength = 0;\n    }\n    this.byteLength = this.shards[this.shards.length - 1].end;\n  }\n  slice() {\n    let start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.byteLength;\n    // NaN is treated as zero for slicing. This matches ArrayBuffer's behavior.\n    start = isNaN(Number(start)) ? 0 : start;\n    end = isNaN(Number(end)) ? 0 : end;\n    // Fix the bounds to within the array.\n    start = Math.max(0, start);\n    end = Math.min(this.byteLength, end);\n    if (end <= start) {\n      return new ArrayBuffer(0);\n    }\n    const startShardIndex = this.findShardForByte(start);\n    if (startShardIndex === -1) {\n      // This should not happen since the start and end indices are always\n      // within 0 and the composite array's length.\n      throw new Error(`Could not find start shard for byte ${start}`);\n    }\n    const size = end - start;\n    const outputBuffer = new ArrayBuffer(size);\n    const outputArray = new Uint8Array(outputBuffer);\n    let sliced = 0;\n    for (let i = startShardIndex; i < this.shards.length; i++) {\n      const shard = this.shards[i];\n      const globalStart = start + sliced;\n      const localStart = globalStart - shard.start;\n      const outputStart = sliced;\n      const globalEnd = Math.min(end, shard.end);\n      const localEnd = globalEnd - shard.start;\n      const outputSlice = new Uint8Array(shard.buffer.slice(localStart, localEnd));\n      outputArray.set(outputSlice, outputStart);\n      sliced += outputSlice.length;\n      if (end < shard.end) {\n        break;\n      }\n    }\n    return outputBuffer;\n  }\n  /**\n   * Get the index of the shard that contains the byte at `byteIndex`.\n   */\n  findShardForByte(byteIndex) {\n    if (this.shards.length === 0 || byteIndex < 0 || byteIndex >= this.byteLength) {\n      return -1;\n    }\n    // If the buffers have a uniform size, compute the shard directly.\n    if (this.bufferUniformSize != null) {\n      this.previousShardIndex = Math.floor(byteIndex / this.bufferUniformSize);\n      return this.previousShardIndex;\n    }\n    // If the buffers don't have a uniform size, we need to search for the\n    // shard. That means we need a function to check where the byteIndex lies\n    // relative to a given shard.\n    function check(shard) {\n      if (byteIndex < shard.start) {\n        return -1;\n      }\n      if (byteIndex >= shard.end) {\n        return 1;\n      }\n      return 0;\n    }\n    // For efficiency, try the previous shard first.\n    if (check(this.shards[this.previousShardIndex]) === 0) {\n      return this.previousShardIndex;\n    }\n    // Otherwise, use a generic search function.\n    // This should almost never end up being used in practice since the weight\n    // entries should always be in order.\n    const index = search(this.shards, check);\n    if (index === -1) {\n      return -1;\n    }\n    this.previousShardIndex = index;\n    return this.previousShardIndex;\n  }\n}\n/**\n * Search for an element of a sorted array.\n *\n * @param sortedArray The sorted array to search\n * @param compare A function to compare the current value against the searched\n *     value. Return 0 on a match, negative if the searched value is less than\n *     the value passed to the function, and positive if the searched value is\n *     greater than the value passed to the function.\n * @returns The index of the element, or -1 if it's not in the array.\n */\nexport function search(sortedArray, compare) {\n  // Binary search\n  let min = 0;\n  let max = sortedArray.length;\n  while (min <= max) {\n    const middle = Math.floor((max - min) / 2) + min;\n    const side = compare(sortedArray[middle]);\n    if (side === 0) {\n      return middle;\n    } else if (side < 0) {\n      max = middle;\n    } else {\n      min = middle + 1;\n    }\n  }\n  return -1;\n}","map":{"version":3,"names":["util","CompositeArrayBuffer","constructor","buffers","shards","previousShardIndex","Array","map","bufferOrTypedArray","isTypedArray","buffer","length","bufferUniformSize","byteLength","start","i","undefined","end","push","slice","arguments","isNaN","Number","Math","max","min","ArrayBuffer","startShardIndex","findShardForByte","Error","size","outputBuffer","outputArray","Uint8Array","sliced","shard","globalStart","localStart","outputStart","globalEnd","localEnd","outputSlice","set","byteIndex","floor","check","index","search","sortedArray","compare","middle","side"],"sources":["/Users/minjeongyeom/Projects/project-wildet/tfjs-core/src/io/composite_array_buffer.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {TypedArray} from '../types';\nimport * as util from '../util';\n\ntype BufferShard = {\n  start: number,\n  end: number,\n  buffer: ArrayBuffer,\n};\n\n/**\n * Wraps a list of ArrayBuffers into a `slice()`-able object without allocating\n * a large ArrayBuffer.\n *\n * Allocating large ArrayBuffers (~2GB) can be unstable on Chrome. TFJS loads\n * its weights as a list of (usually) 4MB ArrayBuffers and then slices the\n * weight tensors out of them. For small models, it's safe to concatenate all\n * the weight buffers into a single ArrayBuffer and then slice the weight\n * tensors out of it, but for large models, a different approach is needed.\n */\n\nexport class CompositeArrayBuffer {\n  private shards: BufferShard[] = [];\n  private previousShardIndex = 0;\n  private bufferUniformSize?: number;\n  public readonly byteLength: number;\n\n  constructor(buffers: ArrayBuffer | ArrayBuffer[] | TypedArray |\n    TypedArray[]) {\n    // Normalize the `buffers` input to be `ArrayBuffer[]`.\n    if (!(buffers instanceof Array)) {\n      buffers = [buffers];\n    }\n    buffers = buffers.map((bufferOrTypedArray) => {\n      if (util.isTypedArray(bufferOrTypedArray)) {\n        return bufferOrTypedArray.buffer;\n      }\n      return bufferOrTypedArray;\n    });\n\n    // Skip setting up shards if there are no buffers.\n    if (buffers.length === 0) {\n      return;\n    }\n\n    this.bufferUniformSize = buffers[0].byteLength;\n    let start = 0;\n\n    for (let i = 0; i < buffers.length; i++) {\n      const buffer = buffers[i];\n      // Check that all buffers except the last one have the same length.\n      if (i !== buffers.length - 1 &&\n        buffer.byteLength !== this.bufferUniformSize) {\n        // Unset the buffer uniform size, since the buffer sizes are not\n        // uniform.\n        this.bufferUniformSize = undefined;\n      }\n\n      // Create the shards, including their start and end points.\n      const end = start + buffer.byteLength;\n      this.shards.push({ buffer, start, end });\n      start = end;\n    }\n\n    // Set the byteLenghth\n    if (this.shards.length === 0) {\n      this.byteLength = 0;\n    }\n    this.byteLength = this.shards[this.shards.length - 1].end;\n  }\n\n  slice(start = 0, end = this.byteLength): ArrayBuffer {\n    // NaN is treated as zero for slicing. This matches ArrayBuffer's behavior.\n    start = isNaN(Number(start)) ? 0 : start;\n    end = isNaN(Number(end)) ? 0 : end;\n\n    // Fix the bounds to within the array.\n    start = Math.max(0, start);\n    end = Math.min(this.byteLength, end);\n    if (end <= start) {\n      return new ArrayBuffer(0);\n    }\n\n    const startShardIndex = this.findShardForByte(start);\n    if (startShardIndex === -1) {\n      // This should not happen since the start and end indices are always\n      // within 0 and the composite array's length.\n      throw new Error(`Could not find start shard for byte ${start}`);\n    }\n\n    const size = end - start;\n    const outputBuffer = new ArrayBuffer(size);\n    const outputArray = new Uint8Array(outputBuffer);\n    let sliced = 0;\n    for (let i = startShardIndex; i < this.shards.length; i++) {\n      const shard = this.shards[i];\n\n      const globalStart = start + sliced;\n      const localStart = globalStart - shard.start;\n      const outputStart = sliced;\n\n      const globalEnd = Math.min(end, shard.end);\n      const localEnd = globalEnd - shard.start;\n\n      const outputSlice = new Uint8Array(shard.buffer.slice(localStart,\n        localEnd));\n      outputArray.set(outputSlice, outputStart);\n      sliced += outputSlice.length;\n\n      if (end < shard.end) {\n        break;\n      }\n    }\n    return outputBuffer;\n  }\n\n  /**\n   * Get the index of the shard that contains the byte at `byteIndex`.\n   */\n  private findShardForByte(byteIndex: number): number {\n    if (this.shards.length === 0 || byteIndex < 0 ||\n      byteIndex >= this.byteLength) {\n      return -1;\n    }\n\n    // If the buffers have a uniform size, compute the shard directly.\n    if (this.bufferUniformSize != null) {\n      this.previousShardIndex = Math.floor(byteIndex / this.bufferUniformSize);\n      return this.previousShardIndex;\n    }\n\n    // If the buffers don't have a uniform size, we need to search for the\n    // shard. That means we need a function to check where the byteIndex lies\n    // relative to a given shard.\n    function check(shard: BufferShard) {\n      if (byteIndex < shard.start) {\n        return -1;\n      }\n      if (byteIndex >= shard.end) {\n        return 1;\n      }\n      return 0;\n    }\n\n    // For efficiency, try the previous shard first.\n    if (check(this.shards[this.previousShardIndex]) === 0) {\n      return this.previousShardIndex;\n    }\n\n    // Otherwise, use a generic search function.\n    // This should almost never end up being used in practice since the weight\n    // entries should always be in order.\n    const index = search(this.shards, check);\n    if (index === -1) {\n      return -1;\n    }\n\n    this.previousShardIndex = index;\n    return this.previousShardIndex;\n  }\n}\n\n/**\n * Search for an element of a sorted array.\n *\n * @param sortedArray The sorted array to search\n * @param compare A function to compare the current value against the searched\n *     value. Return 0 on a match, negative if the searched value is less than\n *     the value passed to the function, and positive if the searched value is\n *     greater than the value passed to the function.\n * @returns The index of the element, or -1 if it's not in the array.\n */\nexport function search<T>(sortedArray: T[], compare: (t: T) => number): number {\n  // Binary search\n  let min = 0;\n  let max = sortedArray.length;\n\n  while (min <= max) {\n    const middle = Math.floor((max - min) / 2) + min;\n    const side = compare(sortedArray[middle]);\n\n    if (side === 0) {\n      return middle;\n    } else if (side < 0) {\n      max = middle;\n    } else {\n      min = middle + 1;\n    }\n  }\n  return -1;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
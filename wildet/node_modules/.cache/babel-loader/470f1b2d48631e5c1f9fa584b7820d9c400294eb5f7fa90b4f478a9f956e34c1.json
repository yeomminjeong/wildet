{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { parseNodeName } from '../operations/executors/utils';\n/**\n * Given graph inputs and desired outputs, find the minimal set of nodes\n * to execute in order to compute the outputs. In addition return other useful\n * info such:\n * - Missing inputs needed to compute the output.\n * - Whether the subgraph contains dynamic ops (control flow, dynamic shape).\n * - Alternative inputs in order to avoid async (dynamic op) execution.\n */\nexport function getExecutionSubgraph(inputs, outputs, weightMap, initNodes) {\n  const usedNodes = new Set();\n  const missingInputs = [];\n  let dynamicNode = null;\n  let syncInputs = null;\n  // Start with the outputs, going backwards and find all the nodes that are\n  // needed to compute those outputs.\n  const seen = new Set();\n  const inputNodeNames = new Set(Object.keys(inputs).map(name => parseNodeName(name)[0]));\n  initNodes = initNodes || [];\n  const initNodeNames = new Set(initNodes.map(node => parseNodeName(node.name)[0]));\n  const frontier = [...outputs];\n  while (frontier.length > 0) {\n    const node = frontier.pop();\n    if (isControlFlow(node) || isDynamicShape(node) || isHashTable(node)) {\n      if (dynamicNode == null) {\n        dynamicNode = node;\n        syncInputs = dynamicNode.children.map(child => child.name).filter(name => usedNodes.has(name));\n      }\n    }\n    usedNodes.add(node.name);\n    // Weights are dead end since we already have their values.\n    if (weightMap[node.name] != null) {\n      continue;\n    }\n    // This node is a dead end since it's one of the user-provided inputs.\n    if (inputNodeNames.has(node.name)) {\n      continue;\n    }\n    // This node is a dead end since it doesn't have any inputs.\n    if (initNodeNames.has(node.name)) {\n      continue;\n    }\n    if (node.inputs.length === 0) {\n      missingInputs.push(node.name);\n      continue;\n    }\n    node.inputs.forEach(input => {\n      // Don't add to the frontier if it is already there.\n      if (seen.has(input.name)) {\n        return;\n      }\n      seen.add(input.name);\n      frontier.push(input);\n    });\n  }\n  return {\n    inputs,\n    outputs,\n    usedNodes,\n    missingInputs,\n    dynamicNode,\n    syncInputs\n  };\n}\n/**\n * Given the execution info, return a list of nodes in topological order that\n * need to be executed to compute the output.\n */\nexport function getNodesInTopologicalOrder(graph, executionInfo) {\n  const {\n    usedNodes,\n    inputs\n  } = executionInfo;\n  const inputNodes = Object.keys(inputs).map(name => parseNodeName(name)[0]).map(name => graph.nodes[name]);\n  const initNodes = graph.initNodes || [];\n  const isUsed = node => usedNodes.has(typeof node === 'string' ? node : node.name);\n  function unique(nodes) {\n    return [...new Map(nodes.map(node => [node.name, node])).values()];\n  }\n  const predefinedNodes = unique([...inputNodes, ...graph.weights, ...initNodes]).filter(isUsed);\n  const allNodes = unique([...predefinedNodes, ...Object.values(graph.nodes)]).filter(isUsed);\n  const nameToNode = new Map(allNodes.map(node => [node.name, node]));\n  const inCounts = {};\n  for (const node of allNodes) {\n    inCounts[node.name] = inCounts[node.name] || 0;\n    for (const child of node.children) {\n      // When the child is unused, set in counts to infinity so that it will\n      // never be decreased to 0 and added to the execution list.\n      if (!isUsed(child)) {\n        inCounts[child.name] = Number.POSITIVE_INFINITY;\n      }\n      inCounts[child.name] = (inCounts[child.name] || 0) + 1;\n    }\n  }\n  // Build execution order for all used nodes regardless whether they are\n  // predefined or not.\n  const frontier = Object.entries(inCounts).filter(_ref => {\n    let [, inCount] = _ref;\n    return inCount === 0;\n  }).map(_ref2 => {\n    let [name] = _ref2;\n    return name;\n  });\n  const orderedNodeNames = [...frontier];\n  while (frontier.length > 0) {\n    const nodeName = frontier.pop();\n    const node = nameToNode.get(nodeName);\n    for (const child of node.children.filter(isUsed)) {\n      if (--inCounts[child.name] === 0) {\n        orderedNodeNames.push(child.name);\n        frontier.push(child.name);\n      }\n    }\n  }\n  const orderedNodes = orderedNodeNames.map(name => nameToNode.get(name));\n  const filteredOrderedNodes = filterPredefinedReachableNodes(orderedNodes, predefinedNodes);\n  // TODO: Turn validation on/off with tf env flag.\n  validateNodesExecutionOrder(filteredOrderedNodes, predefinedNodes);\n  return filteredOrderedNodes;\n}\n/**\n * This is a helper function of `getNodesInTopologicalOrder`.\n * Returns ordered nodes reachable by at least one predefined node.\n * This can help us filter out redundant nodes from the returned node list.\n * For example:\n * If we have four nodes with dependencies like this:\n *   a --> b --> c --> d\n * when node `c` is predefined (e.g. given as an input tensor), we can\n * skip node `a` and `b` since their outputs will never be used.\n *\n * @param orderedNodes Graph nodes in execution order.\n * @param predefinedNodes Graph inputs, weights, and init nodes. Nodes in this\n *     list must have distinct names.\n */\nfunction filterPredefinedReachableNodes(orderedNodes, predefinedNodes) {\n  const nameToNode = new Map(orderedNodes.map(node => [node.name, node]));\n  // TODO: Filter out more nodes when >=2 nodes are predefined in a path.\n  const stack = predefinedNodes.map(node => node.name);\n  const predefinedReachableNodeNames = new Set(stack);\n  // Perform a DFS starting from the set of all predefined nodes\n  // to find the set of all nodes reachable from the predefined nodes.\n  while (stack.length > 0) {\n    const nodeName = stack.pop();\n    const node = nameToNode.get(nodeName);\n    for (const child of node.children) {\n      if (!nameToNode.has(child.name) || predefinedReachableNodeNames.has(child.name)) {\n        continue;\n      }\n      predefinedReachableNodeNames.add(child.name);\n      stack.push(child.name);\n    }\n  }\n  // Filter out unreachable nodes and build the ordered node list.\n  const filteredOrderedNodes = orderedNodes.filter(node => predefinedReachableNodeNames.has(node.name));\n  return filteredOrderedNodes;\n}\nclass NodesExecutionOrderError extends Error {\n  constructor(message) {\n    super(`NodesExecutionOrderError: ${message}`);\n  }\n}\n/**\n * This is a helper function of `getNodesInTopologicalOrder`.\n * Validates property: given nodes `a` and `b`, Order(a) > Order(b) if `a`\n * is a child of `b`. This function throws an error if validation fails.\n *\n * @param orderedNodes Graph nodes in execution order.\n * @param predefinedNodes Graph inputs, weights, and init nodes. Nodes in this\n *     list must have distinct names.\n */\nfunction validateNodesExecutionOrder(orderedNodes, predefinedNodes) {\n  const nodeNameToOrder = new Map(orderedNodes.map((node, order) => [node.name, order]));\n  const predefinedNodeNames = new Set(predefinedNodes.map(node => node.name));\n  const isPredefined = node => predefinedNodeNames.has(typeof node === 'string' ? node : node.name);\n  const willBeExecutedNodeNames = new Set(orderedNodes.map(node => node.name));\n  const willBeExecuted = node => willBeExecutedNodeNames.has(typeof node === 'string' ? node : node.name);\n  for (const node of orderedNodes) {\n    for (const child of node.children.filter(willBeExecuted)) {\n      if (!nodeNameToOrder.has(child.name)) {\n        throw new NodesExecutionOrderError(`Child ${child.name} of node ${node.name} is unreachable.`);\n      }\n      if (nodeNameToOrder.get(node.name) > nodeNameToOrder.get(child.name)) {\n        throw new NodesExecutionOrderError(`Node ${node.name} is scheduled to run after its child ${child.name}.`);\n      }\n    }\n    if (!isPredefined(node)) {\n      for (const input of node.inputs) {\n        if (!nodeNameToOrder.has(input.name)) {\n          throw new NodesExecutionOrderError(`Input ${input.name} of node ${node.name} is unreachable.`);\n        }\n        if (nodeNameToOrder.get(input.name) > nodeNameToOrder.get(node.name)) {\n          throw new NodesExecutionOrderError(`Node ${node.name} is scheduled to run before its input ${input.name}.`);\n        }\n      }\n    }\n  }\n}\n/**\n * Given the execution info, return a map from node name to the disposable\n * node name list after its execution.\n *\n * @returns A map from node name to disposable nodes after its\n *     execution. That is, for a node `x`, `nodeLiveUntilMap[x]` indicates\n *     all nodes which their intermediate tensors should be disposed after `x`\n *     being executed.\n */\nexport function getNodeLiveUntilMap(orderedNodes) {\n  const nodeNameToOrder = new Map(orderedNodes.map((node, order) => [node.name, order]));\n  const INF_LIFE = Number.MAX_SAFE_INTEGER;\n  // Make control flow nodes (and consequently their direct parents)\n  // live forever since they're tricky to track correctly.\n  const selfLifespans = orderedNodes.map((node, nodeOrder) => isControlFlow(node) ? INF_LIFE : nodeOrder);\n  const getSelfLifeSpan = node => {\n    const selfLife = selfLifespans[nodeNameToOrder.get(node.name)];\n    if (selfLife == null) {\n      // If nodeToOrder does not contain the node, it is unused or\n      // unreachable in graph.\n      return -1;\n    }\n    return selfLife;\n  };\n  // `liveUntil[i]` points to the last node in the `orderedNodes` array that\n  // may depend on tensors from node `i`. It indicates that all the\n  // intermediate tensors from `orderedNodes[i]` should be disposed after\n  // `orderedNodes[liveUntil[i]]` is executed.\n  // A node lives long enough to pass on its tensors to its children.\n  // It lives until at least `max(node's position, children's positions)`.\n  const liveUntilOrders = orderedNodes.map((node, nodeOrder) => {\n    return node.children.map(getSelfLifeSpan).reduce((a, b) => Math.max(a, b), selfLifespans[nodeOrder]);\n  });\n  // liveUntilMap:\n  // - Key: Name of a node `x`\n  // - Values: All nodes whose intermediate tensors should be disposed\n  //           after `x` is executed.\n  const liveUntilMap = new Map();\n  for (let nodeOrder = 0; nodeOrder < orderedNodes.length; ++nodeOrder) {\n    const liveUntilOrder = liveUntilOrders[nodeOrder];\n    if (liveUntilOrder === INF_LIFE) {\n      continue;\n    }\n    const node = orderedNodes[nodeOrder];\n    const liveUntilNode = orderedNodes[liveUntilOrder];\n    if (!liveUntilMap.has(liveUntilNode.name)) {\n      liveUntilMap.set(liveUntilNode.name, []);\n    }\n    liveUntilMap.get(liveUntilNode.name).push(node);\n  }\n  return liveUntilMap;\n}\nconst CONTROL_FLOW_OPS = new Set(['Switch', 'Merge', 'Enter', 'Exit', 'NextIteration', 'StatelessIf', 'StatelessWhile', 'if', 'While']);\nconst DYNAMIC_SHAPE_OPS = new Set(['NonMaxSuppressionV2', 'NonMaxSuppressionV3', 'NonMaxSuppressionV5', 'Where']);\nconst HASH_TABLE_OPS = new Set(['HashTable', 'HashTableV2', 'LookupTableImport', 'LookupTableImportV2', 'LookupTableFind', 'LookupTableFindV2', 'LookupTableSize', 'LookupTableSizeV2']);\nexport function isControlFlow(node) {\n  return CONTROL_FLOW_OPS.has(node.op);\n}\nexport function isDynamicShape(node) {\n  return DYNAMIC_SHAPE_OPS.has(node.op);\n}\nexport function isHashTable(node) {\n  return HASH_TABLE_OPS.has(node.op);\n}","map":{"version":3,"names":["parseNodeName","getExecutionSubgraph","inputs","outputs","weightMap","initNodes","usedNodes","Set","missingInputs","dynamicNode","syncInputs","seen","inputNodeNames","Object","keys","map","name","initNodeNames","node","frontier","length","pop","isControlFlow","isDynamicShape","isHashTable","children","child","filter","has","add","push","forEach","input","getNodesInTopologicalOrder","graph","executionInfo","inputNodes","nodes","isUsed","unique","Map","values","predefinedNodes","weights","allNodes","nameToNode","inCounts","Number","POSITIVE_INFINITY","entries","_ref","inCount","_ref2","orderedNodeNames","nodeName","get","orderedNodes","filteredOrderedNodes","filterPredefinedReachableNodes","validateNodesExecutionOrder","stack","predefinedReachableNodeNames","NodesExecutionOrderError","Error","constructor","message","nodeNameToOrder","order","predefinedNodeNames","isPredefined","willBeExecutedNodeNames","willBeExecuted","getNodeLiveUntilMap","INF_LIFE","MAX_SAFE_INTEGER","selfLifespans","nodeOrder","getSelfLifeSpan","selfLife","liveUntilOrders","reduce","a","b","Math","max","liveUntilMap","liveUntilOrder","liveUntilNode","set","CONTROL_FLOW_OPS","DYNAMIC_SHAPE_OPS","HASH_TABLE_OPS","op"],"sources":["/Users/minjeongyeom/Projects/project-wildet/tfjs-converter/src/executor/model_analysis.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {NamedTensorMap} from '@tensorflow/tfjs-core';\n\nimport {NamedTensorsMap} from '../data/types';\nimport {parseNodeName} from '../operations/executors/utils';\nimport {Graph, Node} from '../operations/types';\n\nexport interface ExecutionInfo {\n  inputs: NamedTensorMap;\n  outputs: Node[];\n  usedNodes: Set<string>;\n  missingInputs: string[];\n  dynamicNode: Node;\n  syncInputs: string[];\n}\n\n/**\n * Given graph inputs and desired outputs, find the minimal set of nodes\n * to execute in order to compute the outputs. In addition return other useful\n * info such:\n * - Missing inputs needed to compute the output.\n * - Whether the subgraph contains dynamic ops (control flow, dynamic shape).\n * - Alternative inputs in order to avoid async (dynamic op) execution.\n */\nexport function getExecutionSubgraph(\n    inputs: NamedTensorMap, outputs: Node[], weightMap: NamedTensorsMap,\n    initNodes?: Node[]): ExecutionInfo {\n  const usedNodes = new Set<string>();\n  const missingInputs: string[] = [];\n  let dynamicNode: Node = null;\n  let syncInputs: string[] = null;\n\n  // Start with the outputs, going backwards and find all the nodes that are\n  // needed to compute those outputs.\n  const seen = new Set<string>();\n  const inputNodeNames =\n      new Set(Object.keys(inputs).map((name) => parseNodeName(name)[0]));\n\n  initNodes = initNodes || [];\n  const initNodeNames =\n      new Set(initNodes.map((node) => parseNodeName(node.name)[0]));\n\n  const frontier = [...outputs];\n  while (frontier.length > 0) {\n    const node = frontier.pop();\n    if (isControlFlow(node) || isDynamicShape(node) || isHashTable(node)) {\n      if (dynamicNode == null) {\n        dynamicNode = node;\n        syncInputs = dynamicNode.children.map(child => child.name)\n                         .filter(name => usedNodes.has(name));\n      }\n    }\n    usedNodes.add(node.name);\n\n    // Weights are dead end since we already have their values.\n    if (weightMap[node.name] != null) {\n      continue;\n    }\n    // This node is a dead end since it's one of the user-provided inputs.\n    if (inputNodeNames.has(node.name)) {\n      continue;\n    }\n    // This node is a dead end since it doesn't have any inputs.\n    if (initNodeNames.has(node.name)) {\n      continue;\n    }\n    if (node.inputs.length === 0) {\n      missingInputs.push(node.name);\n      continue;\n    }\n    node.inputs.forEach(input => {\n      // Don't add to the frontier if it is already there.\n      if (seen.has(input.name)) {\n        return;\n      }\n      seen.add(input.name);\n      frontier.push(input);\n    });\n  }\n  return {inputs, outputs, usedNodes, missingInputs, dynamicNode, syncInputs};\n}\n\n/**\n * Given the execution info, return a list of nodes in topological order that\n * need to be executed to compute the output.\n */\nexport function getNodesInTopologicalOrder(\n    graph: Graph, executionInfo: ExecutionInfo): Node[] {\n  const {usedNodes, inputs} = executionInfo;\n  const inputNodes = Object.keys(inputs)\n                         .map(name => parseNodeName(name)[0])\n                         .map(name => graph.nodes[name]);\n  const initNodes = graph.initNodes || [];\n\n  const isUsed = (node: Node|string) =>\n      usedNodes.has(typeof node === 'string' ? node : node.name);\n\n  function unique(nodes: Node[]): Node[] {\n    return [...new Map(nodes.map((node) => [node.name, node])).values()];\n  }\n  const predefinedNodes = unique([\n                            ...inputNodes,\n                            ...graph.weights,\n                            ...initNodes,\n                          ]).filter(isUsed);\n  const allNodes = unique([\n                     ...predefinedNodes,\n                     ...Object.values(graph.nodes),\n                   ]).filter(isUsed);\n  const nameToNode =\n      new Map<string, Node>(allNodes.map((node) => [node.name, node]));\n\n  const inCounts: Record<string, number> = {};\n  for (const node of allNodes) {\n    inCounts[node.name] = inCounts[node.name] || 0;\n    for (const child of node.children) {\n      // When the child is unused, set in counts to infinity so that it will\n      // never be decreased to 0 and added to the execution list.\n      if (!isUsed(child)) {\n        inCounts[child.name] = Number.POSITIVE_INFINITY;\n      }\n      inCounts[child.name] = (inCounts[child.name] || 0) + 1;\n    }\n  }\n\n  // Build execution order for all used nodes regardless whether they are\n  // predefined or not.\n  const frontier = Object.entries(inCounts)\n                       .filter(([, inCount]) => inCount === 0)\n                       .map(([name]) => name);\n  const orderedNodeNames = [...frontier];\n  while (frontier.length > 0) {\n    const nodeName = frontier.pop();\n    const node = nameToNode.get(nodeName)!;\n    for (const child of node.children.filter(isUsed)) {\n      if (--inCounts[child.name] === 0) {\n        orderedNodeNames.push(child.name);\n        frontier.push(child.name);\n      }\n    }\n  }\n\n  const orderedNodes = orderedNodeNames.map((name) => nameToNode.get(name));\n  const filteredOrderedNodes =\n      filterPredefinedReachableNodes(orderedNodes, predefinedNodes);\n\n  // TODO: Turn validation on/off with tf env flag.\n  validateNodesExecutionOrder(filteredOrderedNodes, predefinedNodes);\n\n  return filteredOrderedNodes;\n}\n\n/**\n * This is a helper function of `getNodesInTopologicalOrder`.\n * Returns ordered nodes reachable by at least one predefined node.\n * This can help us filter out redundant nodes from the returned node list.\n * For example:\n * If we have four nodes with dependencies like this:\n *   a --> b --> c --> d\n * when node `c` is predefined (e.g. given as an input tensor), we can\n * skip node `a` and `b` since their outputs will never be used.\n *\n * @param orderedNodes Graph nodes in execution order.\n * @param predefinedNodes Graph inputs, weights, and init nodes. Nodes in this\n *     list must have distinct names.\n */\nfunction filterPredefinedReachableNodes(\n    orderedNodes: Node[], predefinedNodes: Node[]) {\n  const nameToNode =\n      new Map<string, Node>(orderedNodes.map((node) => [node.name, node]));\n\n  // TODO: Filter out more nodes when >=2 nodes are predefined in a path.\n  const stack = predefinedNodes.map((node) => node.name);\n  const predefinedReachableNodeNames = new Set(stack);\n  // Perform a DFS starting from the set of all predefined nodes\n  // to find the set of all nodes reachable from the predefined nodes.\n  while (stack.length > 0) {\n    const nodeName = stack.pop();\n    const node = nameToNode.get(nodeName)!;\n    for (const child of node.children) {\n      if (!nameToNode.has(child.name) ||\n          predefinedReachableNodeNames.has(child.name)) {\n        continue;\n      }\n      predefinedReachableNodeNames.add(child.name);\n      stack.push(child.name);\n    }\n  }\n\n  // Filter out unreachable nodes and build the ordered node list.\n  const filteredOrderedNodes = orderedNodes.filter(\n      (node) => predefinedReachableNodeNames.has(node.name));\n\n  return filteredOrderedNodes;\n}\n\nclass NodesExecutionOrderError extends Error {\n  constructor(message: string) {\n    super(`NodesExecutionOrderError: ${message}`);\n  }\n}\n\n/**\n * This is a helper function of `getNodesInTopologicalOrder`.\n * Validates property: given nodes `a` and `b`, Order(a) > Order(b) if `a`\n * is a child of `b`. This function throws an error if validation fails.\n *\n * @param orderedNodes Graph nodes in execution order.\n * @param predefinedNodes Graph inputs, weights, and init nodes. Nodes in this\n *     list must have distinct names.\n */\nfunction validateNodesExecutionOrder(\n    orderedNodes: Node[], predefinedNodes: Node[]) {\n  const nodeNameToOrder = new Map<string, number>(\n      orderedNodes.map((node, order) => [node.name, order]));\n  const predefinedNodeNames = new Set(predefinedNodes.map((node) => node.name));\n  const isPredefined = (node: Node|string) =>\n      predefinedNodeNames.has(typeof node === 'string' ? node : node.name);\n  const willBeExecutedNodeNames =\n      new Set(orderedNodes.map((node) => node.name));\n  const willBeExecuted = (node: Node|string) =>\n      willBeExecutedNodeNames.has(typeof node === 'string' ? node : node.name);\n\n  for (const node of orderedNodes) {\n    for (const child of node.children.filter(willBeExecuted)) {\n      if (!nodeNameToOrder.has(child.name)) {\n        throw new NodesExecutionOrderError(\n            `Child ${child.name} of node ${node.name} is unreachable.`);\n      }\n      if (nodeNameToOrder.get(node.name) > nodeNameToOrder.get(child.name)) {\n        throw new NodesExecutionOrderError(`Node ${\n            node.name} is scheduled to run after its child ${child.name}.`);\n      }\n    }\n    if (!isPredefined(node)) {\n      for (const input of node.inputs) {\n        if (!nodeNameToOrder.has(input.name)) {\n          throw new NodesExecutionOrderError(\n              `Input ${input.name} of node ${node.name} is unreachable.`);\n        }\n        if (nodeNameToOrder.get(input.name) > nodeNameToOrder.get(node.name)) {\n          throw new NodesExecutionOrderError(`Node ${\n              node.name} is scheduled to run before its input ${input.name}.`);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Given the execution info, return a map from node name to the disposable\n * node name list after its execution.\n *\n * @returns A map from node name to disposable nodes after its\n *     execution. That is, for a node `x`, `nodeLiveUntilMap[x]` indicates\n *     all nodes which their intermediate tensors should be disposed after `x`\n *     being executed.\n */\nexport function getNodeLiveUntilMap(orderedNodes: Node[]): Map<string, Node[]> {\n  const nodeNameToOrder = new Map<string, number>(\n      orderedNodes.map((node, order) => [node.name, order]));\n\n  const INF_LIFE = Number.MAX_SAFE_INTEGER;\n  // Make control flow nodes (and consequently their direct parents)\n  // live forever since they're tricky to track correctly.\n  const selfLifespans = orderedNodes.map(\n      (node, nodeOrder) => isControlFlow(node) ? INF_LIFE : nodeOrder);\n  const getSelfLifeSpan = (node: Node) => {\n    const selfLife = selfLifespans[nodeNameToOrder.get(node.name)!];\n    if (selfLife == null) {\n      // If nodeToOrder does not contain the node, it is unused or\n      // unreachable in graph.\n      return -1;\n    }\n    return selfLife;\n  };\n\n  // `liveUntil[i]` points to the last node in the `orderedNodes` array that\n  // may depend on tensors from node `i`. It indicates that all the\n  // intermediate tensors from `orderedNodes[i]` should be disposed after\n  // `orderedNodes[liveUntil[i]]` is executed.\n  // A node lives long enough to pass on its tensors to its children.\n  // It lives until at least `max(node's position, children's positions)`.\n  const liveUntilOrders = orderedNodes.map((node, nodeOrder) => {\n    return node.children.map(getSelfLifeSpan)\n        .reduce((a, b) => Math.max(a, b), selfLifespans[nodeOrder]);\n  });\n\n  // liveUntilMap:\n  // - Key: Name of a node `x`\n  // - Values: All nodes whose intermediate tensors should be disposed\n  //           after `x` is executed.\n  const liveUntilMap = new Map<string, Node[]>();\n  for (let nodeOrder = 0; nodeOrder < orderedNodes.length; ++nodeOrder) {\n    const liveUntilOrder = liveUntilOrders[nodeOrder];\n    if (liveUntilOrder === INF_LIFE) {\n      continue;\n    }\n    const node = orderedNodes[nodeOrder];\n    const liveUntilNode = orderedNodes[liveUntilOrder];\n    if (!liveUntilMap.has(liveUntilNode.name)) {\n      liveUntilMap.set(liveUntilNode.name, []);\n    }\n    liveUntilMap.get(liveUntilNode.name)!.push(node);\n  }\n  return liveUntilMap;\n}\n\nconst CONTROL_FLOW_OPS = new Set([\n  'Switch', 'Merge', 'Enter', 'Exit', 'NextIteration', 'StatelessIf',\n  'StatelessWhile', 'if', 'While'\n]);\nconst DYNAMIC_SHAPE_OPS = new Set([\n  'NonMaxSuppressionV2', 'NonMaxSuppressionV3', 'NonMaxSuppressionV5', 'Where'\n]);\nconst HASH_TABLE_OPS = new Set([\n  'HashTable', 'HashTableV2', 'LookupTableImport', 'LookupTableImportV2',\n  'LookupTableFind', 'LookupTableFindV2', 'LookupTableSize', 'LookupTableSizeV2'\n]);\n\nexport function isControlFlow(node: Node) {\n  return CONTROL_FLOW_OPS.has(node.op);\n}\n\nexport function isDynamicShape(node: Node) {\n  return DYNAMIC_SHAPE_OPS.has(node.op);\n}\n\nexport function isHashTable(node: Node) {\n  return HASH_TABLE_OPS.has(node.op);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, broadcastTo, reshape, tidy, util } from '@tensorflow/tfjs-core';\nvar RowPartitionType = backend_util.RowPartitionType;\n// Based on\n// https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc\nclass RaggedTensorToTensorOp {\n  constructor(shape, shapeShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypeStrings) {\n    this.shape = shape;\n    this.shapeShape = shapeShape;\n    this.values = values;\n    this.valuesShape = valuesShape;\n    this.valuesDType = valuesDType;\n    this.defaultValue = defaultValue;\n    this.defaultValueShape = defaultValueShape;\n    this.rowPartitionValues = rowPartitionValues;\n    this.rowPartitionValuesShapes = rowPartitionValuesShapes;\n    this.rowPartitionTypes = backend_util.getRowPartitionTypesHelper(rowPartitionTypeStrings);\n    this.raggedRank = backend_util.getRaggedRank(this.rowPartitionTypes);\n  }\n  getRowPartitionTypeByDimension(dimension) {\n    if (this.rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n      return this.rowPartitionTypes[dimension + 1];\n    } else {\n      return this.rowPartitionTypes[dimension];\n    }\n  }\n  // Returns the relationship between dimension and dimension + 1.\n  getRowPartitionTensor(dimension) {\n    if (this.rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n      return this.rowPartitionValues[dimension + 1];\n    } else {\n      return this.rowPartitionValues[dimension];\n    }\n  }\n  getMaxWidth(dimension) {\n    const rowPartitionTensor = this.getRowPartitionTensor(dimension - 1);\n    switch (this.getRowPartitionTypeByDimension(dimension - 1)) {\n      case RowPartitionType.VALUE_ROWIDS:\n        return RaggedTensorToTensorOp.getMaxWidthValueRowID(rowPartitionTensor);\n      case RowPartitionType.ROW_SPLITS:\n        return RaggedTensorToTensorOp.getMaxWidthRowSplit(rowPartitionTensor);\n      default:\n        throw new Error(`Cannot handle partition type ${RowPartitionType[this.getRowPartitionTypeByDimension(dimension - 1)]}`);\n    }\n  }\n  static getMaxWidthRowSplit(rowSplit) {\n    const tensorLength = rowSplit.length;\n    if (tensorLength === 0 || tensorLength === 1) {\n      return 0;\n    }\n    let maxWidth = 0;\n    for (let i = 0; i < tensorLength - 1; ++i) {\n      const currentWidth = rowSplit[i + 1] - rowSplit[i];\n      if (currentWidth > maxWidth) {\n        maxWidth = currentWidth;\n      }\n    }\n    return maxWidth;\n  }\n  static getMaxWidthValueRowID(valueRowIds) {\n    const indexLength = valueRowIds.length;\n    if (indexLength === 0) {\n      return 0;\n    }\n    let firstEqualIndex = 0;\n    let firstEqualIndexValue = valueRowIds[0];\n    let maxWidth = 0;\n    for (let i = 1; i < indexLength; ++i) {\n      const value = valueRowIds[i];\n      if (value !== firstEqualIndexValue) {\n        firstEqualIndexValue = value;\n        maxWidth = Math.max(i - firstEqualIndex, maxWidth);\n        firstEqualIndex = i;\n      }\n    }\n    return Math.max(indexLength - firstEqualIndex, maxWidth);\n  }\n  tensorShapeFromTensor(t, tShape) {\n    let isPartial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (tShape.length === 0) {\n      if (t[0] === -1) {\n        return [];\n      }\n      throw new Error(`The only valid scalar shape tensor is the fully unknown shape specified as -1.`);\n    }\n    // MakePartialShape/MakeShapeHelper.\n    return makeShape(t, isPartial);\n  }\n  calculateOutputSize(firstDim) {\n    const valueShape = this.valuesShape;\n    const defaultValueShape = this.defaultValueShape;\n    backend_util.validateDefaultValueShape(defaultValueShape, valueShape);\n    const shape = this.tensorShapeFromTensor(this.shape, this.shapeShape);\n    const outputShape = backend_util.combineRaggedTensorToTensorShapes(this.raggedRank, shape, valueShape);\n    const result = outputShape;\n    if (result[0] < 0) {\n      result[0] = firstDim;\n    }\n    for (let i = 1; i <= this.raggedRank; ++i) {\n      if (result[i] < 0) {\n        result[i] = this.getMaxWidth(i);\n      }\n    }\n    return result;\n  }\n  /**\n   * The outputIndex represents the index in the output tensor\n   * where the first element of a particular dimension would be written.\n   * If it is -1, it indicates that the index is out of scope.\n   * Example, given firstDimension = 10, firstDimensionOutput = 6,\n   * and outputIndexMultiplier = 100:\n   * result = [0 100 200 300 400 500 -1 -1 -1 -1]\n   * If firstDimensionOutput = 11 instead, then:\n   * result = [0 100 200 300 400 500 600 700 800 900]\n   */\n  calculateFirstParentOutputIndex(firstDimension, outputIndexMultiplier, firstDimensionOutput) {\n    const minDimension = Math.min(firstDimension, firstDimensionOutput);\n    const result = [];\n    let currentOutputIndex = 0;\n    for (let i = 0; i < minDimension; ++i, currentOutputIndex += outputIndexMultiplier) {\n      result.push(currentOutputIndex);\n    }\n    for (let i = minDimension; i < firstDimension; ++i) {\n      result.push(-1);\n    }\n    util.assert(result.length === firstDimension, () => 'Final length of result must be equal to firstDimension.');\n    return result;\n  }\n  calculateOutputIndexRowSplit(rowSplit, parentOutputIndex, outputIndexMultiplier, outputSize) {\n    const rowSplitSize = rowSplit.length;\n    const result = [];\n    for (let i = 0; i < rowSplitSize - 1; ++i) {\n      const rowLength = rowSplit[i + 1] - rowSplit[i];\n      let realLength = Math.min(outputSize, rowLength);\n      let parentOutputIndexCurrent = parentOutputIndex[i];\n      if (parentOutputIndexCurrent === -1) {\n        realLength = 0;\n      }\n      for (let j = 0; j < realLength; ++j) {\n        result.push(parentOutputIndexCurrent);\n        parentOutputIndexCurrent += outputIndexMultiplier;\n      }\n      for (let j = 0; j < rowLength - realLength; ++j) {\n        result.push(-1);\n      }\n    }\n    if (rowSplitSize > 0 && result.length !== rowSplit[rowSplitSize - 1]) {\n      throw new Error('Invalid row split size.');\n    }\n    return result;\n  }\n  // Calculate the output index of the first element of a list.\n  // The parentOutputIndex is the same computation for the previous list.\n  // -1 indicates an element or list that is out of range.\n  // The outputIndexMultiplier is the number of output indices one moves\n  // forward for each column.\n  // E.g., given:\n  // valueRowIds:[0 1 2 2 2 3 5 5 6]\n  // parentOutputIndex:[1000 1100 2000 2100 -1 3000 4000]\n  // outputIndexMultiplier: 10\n  // outputSize: 2\n  // You get:\n  // result = [1000 1100 2000 2010 -1 2100 -1 -1 3000]\n  // result[0] = parentOutputIndex[valueRowIds[0]]\n  // result[1] = parentOutputIndex[valueRowIds[1]]\n  // result[2] = parentOutputIndex[valueRowIds[2]]\n  // result[3] = parentOutputIndex[valueRowIds[2] + 10]\n  // result[4] = -1 because it is the third element the size is 2.\n  // result[5] = parentOutputIndex[valueRowIds[3]]\n  // result[6] = -1 because parentOutputIndex[valueRowIds[6]] == -1\n  // result[7] = -1 because parentOutputIndex[valueRowIds[6]] == -1\n  // result[8] = parentOutputIndex[valueRowIds[7]]\n  calculateOutputIndexValueRowID(valueRowIds, parentOutputIndex, outputIndexMultiplier, outputSize) {\n    const indexSize = valueRowIds.length;\n    const result = [];\n    if (indexSize === 0) {\n      return [];\n    }\n    let currentOutputColumn = 0;\n    let currentValueRowId = valueRowIds[0];\n    if (currentValueRowId >= parentOutputIndex.length) {\n      throw new Error(`Got currentValueRowId=${currentValueRowId}, which is not less than ${parentOutputIndex.length}`);\n    }\n    let currentOutputIndex = parentOutputIndex[currentValueRowId];\n    result.push(currentOutputIndex);\n    for (let i = 1; i < indexSize; ++i) {\n      const nextValueRowId = valueRowIds[i];\n      if (nextValueRowId === currentValueRowId) {\n        if (currentOutputIndex >= 0) {\n          ++currentOutputColumn;\n          if (currentOutputColumn < outputSize) {\n            currentOutputIndex += outputIndexMultiplier;\n          } else {\n            currentOutputIndex = -1;\n          }\n        }\n      } else {\n        currentOutputColumn = 0;\n        currentValueRowId = nextValueRowId;\n        if (nextValueRowId >= parentOutputIndex.length) {\n          throw new Error(`Got nextValueRowId=${nextValueRowId} which is not less than ${parentOutputIndex.length}`);\n        }\n        currentOutputIndex = parentOutputIndex[nextValueRowId];\n      }\n      result.push(currentOutputIndex);\n    }\n    if (result.length !== valueRowIds.length) {\n      throw new Error('Invalid row ids.');\n    }\n    return result;\n  }\n  calculateOutputIndex(dimension, parentOutputIndex, outputIndexMultiplier, outputSize) {\n    const rowPartitionTensor = this.getRowPartitionTensor(dimension);\n    const partitionType = this.getRowPartitionTypeByDimension(dimension);\n    switch (partitionType) {\n      case RowPartitionType.VALUE_ROWIDS:\n        return this.calculateOutputIndexValueRowID(rowPartitionTensor, parentOutputIndex, outputIndexMultiplier, outputSize);\n      case RowPartitionType.ROW_SPLITS:\n        if (rowPartitionTensor.length - 1 > parentOutputIndex.length) {\n          throw new Error(`Row partition size is greater than output size: ${rowPartitionTensor.length - 1} > ${parentOutputIndex.length}`);\n        }\n        return this.calculateOutputIndexRowSplit(rowPartitionTensor, parentOutputIndex, outputIndexMultiplier, outputSize);\n      default:\n        throw new Error(`Unsupported partition type: ${RowPartitionType[partitionType]}`);\n    }\n  }\n  getFirstDimensionSize() {\n    const firstPartitionTensor = this.rowPartitionValues[0];\n    if (this.rowPartitionTypes.length === 0) {\n      throw new Error('No row_partition_types given.');\n    }\n    const firstPartitionType = this.rowPartitionTypes[0];\n    switch (firstPartitionType) {\n      case RowPartitionType.FIRST_DIM_SIZE:\n        return firstPartitionTensor[0];\n      case RowPartitionType.VALUE_ROWIDS:\n        throw new Error('Cannot handle VALUE_ROWIDS in first dimension.');\n      case RowPartitionType.ROW_SPLITS:\n        return this.rowPartitionValuesShapes[0][0] - 1;\n      default:\n        throw new Error(`Cannot handle type ${RowPartitionType[firstPartitionType]}`);\n    }\n  }\n  compute() {\n    const firstPartitionTensor = this.rowPartitionValues[0];\n    if (firstPartitionTensor.length <= 0) {\n      throw new Error('Invalid first partition input. ' + 'Tensor requires at least one element.');\n    }\n    const firstDimension = this.getFirstDimensionSize();\n    const outputSize = this.calculateOutputSize(firstDimension);\n    const multiplier = new Array(this.raggedRank + 1);\n    multiplier[multiplier.length - 1] = 1;\n    for (let i = multiplier.length - 2; i >= 0; --i) {\n      multiplier[i] = multiplier[i + 1] * outputSize[i + 1];\n    }\n    // Full size of the tensor.\n    const outputShape = makeShape(outputSize, false);\n    const outputTensor = util.getArrayFromDType(this.valuesDType, util.sizeFromShape(outputShape));\n    const fullSize = multiplier[0] * outputSize[0];\n    if (fullSize > 0) {\n      let outputIndex = this.calculateFirstParentOutputIndex(firstDimension, multiplier[0], outputSize[0]);\n      for (let i = 1; i <= this.raggedRank; ++i) {\n        const newOutputIndex = this.calculateOutputIndex(i - 1, outputIndex, multiplier[i], outputSize[i]);\n        outputIndex = newOutputIndex;\n      }\n      this.setOutput(this.raggedRank, outputIndex, outputTensor, outputShape);\n    }\n    return [outputShape, outputTensor];\n  }\n  setOutput(raggedRank, outputIndex, outputTensor, outputShape) {\n    if (outputTensor.length === 0) {\n      return;\n    }\n    const valuesBase = this.values;\n    const outputBase = outputTensor;\n    let elementShape = outputShape.slice();\n    elementShape = elementShape.slice(raggedRank + 1);\n    const valueElementSize = util.sizeFromShape(elementShape);\n    const outputIndexSize = outputIndex.length;\n    // Broadcast the default value to value_element_size.  (We can skip this\n    // if defaultValueTensor.size == 1, since we use fill when that's true.)\n    let defaultValue = this.defaultValue;\n    if (defaultValue.length !== valueElementSize && defaultValue.length !== 1) {\n      const srcShape = this.defaultValueShape;\n      tidy(() => {\n        const defaultValueTensor = reshape(defaultValue, srcShape);\n        const bCastDefault = broadcastTo(defaultValueTensor, elementShape);\n        defaultValue = bCastDefault.dataSync();\n      });\n    }\n    // Loop through the outputIndex array, finding contiguous regions that\n    // should be copied.  Once we find the end of a contiguous region, copy it\n    // and add any necessary padding (with defaultValue).\n    let srcStart = 0; // Start of contiguous region (in values)\n    let dstStart = 0; // Destination for contiguous region (in output)\n    let dstEnd = 0; // Destination for contiguous region (in output)\n    for (let srcI = 0; srcI <= outputIndexSize; ++srcI) {\n      // dstI is the destination where the value at srcI should be copied.\n      let dstI = srcI < outputIndexSize ? outputIndex[srcI] : -1;\n      // If we're still in a contiguous region, then update dstEnd go to the\n      // next srcI.\n      if (dstI === dstEnd) {\n        ++dstEnd;\n        continue;\n      }\n      // We found the end of contiguous region.  This can be because we found\n      // a gap (dstI > dstEnd), or a source value that shouldn't be copied\n      // because it's out-of-bounds (dstI == -1), or the end of the tensor\n      // (dstI === -1).\n      if (dstStart < dstEnd) {\n        // Copy the contiguous region.\n        const src = valuesBase.subarray(srcStart * valueElementSize);\n        const dst = outputBase.subarray(dstStart * valueElementSize);\n        const nVals = (dstEnd - dstStart) * valueElementSize;\n        copyArray(dst, src, nVals);\n      }\n      // Add any necessary padding (w/ defaultValue).\n      if (srcI >= outputIndexSize) {\n        // We reached the end of values: pad to the end of output.\n        const outputSize = outputTensor.length;\n        dstI = Math.floor(outputSize / valueElementSize);\n      }\n      if (dstI > dstEnd) {\n        if (this.defaultValue.length === 1) {\n          outputBase.subarray(dstEnd * valueElementSize, dstI * valueElementSize).fill(this.defaultValue[0]);\n          dstEnd = dstI;\n        } else {\n          while (dstI > dstEnd) {\n            const dst = outputBase.slice(dstEnd * valueElementSize);\n            copyArray(dst, defaultValue, valueElementSize);\n            ++dstEnd;\n          }\n        }\n      }\n      // Update indices.\n      if (dstI < 0) {\n        // srcI should be skipped -- leave it out of the contiguous region.\n        srcStart = srcI + 1;\n        dstStart = dstEnd;\n      } else {\n        // srcI should be copied -- include it in the contiguous region.\n        srcStart = srcI;\n        dstStart = dstEnd;\n        dstEnd = dstStart + 1;\n      }\n    }\n  }\n}\nfunction copyArray(dst, src, size) {\n  for (let i = 0; i < size; i++) {\n    dst[i] = src[i];\n  }\n}\nfunction makeShape(shape, isPartial) {\n  const out = [];\n  for (let dim of shape) {\n    if (dim < 0) {\n      if (!isPartial) {\n        throw new Error(`Dimension ${dim} must be >= 0`);\n      }\n      if (dim < -1) {\n        throw new Error(`Dimension ${dim} must be >= -1`);\n      }\n      dim = -1;\n    }\n    out.push(dim);\n  }\n  return out;\n}\nexport function raggedTensorToTensorImpl(shape, shapesShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypes) {\n  return new RaggedTensorToTensorOp(shape, shapesShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypes).compute();\n}","map":{"version":3,"names":["backend_util","broadcastTo","reshape","tidy","util","RowPartitionType","RaggedTensorToTensorOp","constructor","shape","shapeShape","values","valuesShape","valuesDType","defaultValue","defaultValueShape","rowPartitionValues","rowPartitionValuesShapes","rowPartitionTypeStrings","rowPartitionTypes","getRowPartitionTypesHelper","raggedRank","getRaggedRank","getRowPartitionTypeByDimension","dimension","FIRST_DIM_SIZE","getRowPartitionTensor","getMaxWidth","rowPartitionTensor","VALUE_ROWIDS","getMaxWidthValueRowID","ROW_SPLITS","getMaxWidthRowSplit","Error","rowSplit","tensorLength","length","maxWidth","i","currentWidth","valueRowIds","indexLength","firstEqualIndex","firstEqualIndexValue","value","Math","max","tensorShapeFromTensor","t","tShape","isPartial","arguments","undefined","makeShape","calculateOutputSize","firstDim","valueShape","validateDefaultValueShape","outputShape","combineRaggedTensorToTensorShapes","result","calculateFirstParentOutputIndex","firstDimension","outputIndexMultiplier","firstDimensionOutput","minDimension","min","currentOutputIndex","push","assert","calculateOutputIndexRowSplit","parentOutputIndex","outputSize","rowSplitSize","rowLength","realLength","parentOutputIndexCurrent","j","calculateOutputIndexValueRowID","indexSize","currentOutputColumn","currentValueRowId","nextValueRowId","calculateOutputIndex","partitionType","getFirstDimensionSize","firstPartitionTensor","firstPartitionType","compute","multiplier","Array","outputTensor","getArrayFromDType","sizeFromShape","fullSize","outputIndex","newOutputIndex","setOutput","valuesBase","outputBase","elementShape","slice","valueElementSize","outputIndexSize","srcShape","defaultValueTensor","bCastDefault","dataSync","srcStart","dstStart","dstEnd","srcI","dstI","src","subarray","dst","nVals","copyArray","floor","fill","size","out","dim","raggedTensorToTensorImpl","shapesShape"],"sources":["/Users/minjeongyeom/Projects/project-wildet/tfjs-backend-cpu/src/kernels/RaggedTensorToTensor_impl.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, broadcastTo, DataType, reshape, tidy, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport RowPartitionType = backend_util.RowPartitionType;\n// Based on\n// https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc\nclass RaggedTensorToTensorOp {\n  private readonly rowPartitionTypes: RowPartitionType[];\n  private readonly raggedRank: number;\n  constructor(\n      private shape: TypedArray, private shapeShape: number[],\n      private values: TypedArray, private valuesShape: number[],\n      private valuesDType: DataType, private defaultValue: TypedArray,\n      private defaultValueShape: number[],\n      private readonly rowPartitionValues: TypedArray[],\n      private readonly rowPartitionValuesShapes: number[][],\n      rowPartitionTypeStrings: string[]) {\n    this.rowPartitionTypes =\n        backend_util.getRowPartitionTypesHelper(rowPartitionTypeStrings);\n    this.raggedRank = backend_util.getRaggedRank(this.rowPartitionTypes);\n  }\n\n  private getRowPartitionTypeByDimension(dimension: number) {\n    if (this.rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n      return this.rowPartitionTypes[dimension + 1];\n    } else {\n      return this.rowPartitionTypes[dimension];\n    }\n  }\n\n  // Returns the relationship between dimension and dimension + 1.\n  private getRowPartitionTensor(dimension: number) {\n    if (this.rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n      return this.rowPartitionValues[dimension + 1];\n    } else {\n      return this.rowPartitionValues[dimension];\n    }\n  }\n\n  private getMaxWidth(dimension: number) {\n    const rowPartitionTensor = this.getRowPartitionTensor(dimension - 1);\n    switch (this.getRowPartitionTypeByDimension(dimension - 1)) {\n      case RowPartitionType.VALUE_ROWIDS:\n        return RaggedTensorToTensorOp.getMaxWidthValueRowID(rowPartitionTensor);\n      case RowPartitionType.ROW_SPLITS:\n        return RaggedTensorToTensorOp.getMaxWidthRowSplit(rowPartitionTensor);\n      default:\n        throw new Error(`Cannot handle partition type ${\n            RowPartitionType[this.getRowPartitionTypeByDimension(\n                dimension - 1)]}`);\n    }\n  }\n\n  static getMaxWidthRowSplit(rowSplit: TypedArray) {\n    const tensorLength = rowSplit.length;\n    if (tensorLength === 0 || tensorLength === 1) {\n      return 0;\n    }\n    let maxWidth = 0;\n    for (let i = 0; i < tensorLength - 1; ++i) {\n      const currentWidth = rowSplit[i + 1] - rowSplit[i];\n      if (currentWidth > maxWidth) {\n        maxWidth = currentWidth;\n      }\n    }\n    return maxWidth;\n  }\n\n  static getMaxWidthValueRowID(valueRowIds: TypedArray) {\n    const indexLength = valueRowIds.length;\n    if (indexLength === 0) {\n      return 0;\n    }\n    let firstEqualIndex = 0;\n    let firstEqualIndexValue = valueRowIds[0];\n    let maxWidth = 0;\n    for (let i = 1; i < indexLength; ++i) {\n      const value = valueRowIds[i];\n      if (value !== firstEqualIndexValue) {\n        firstEqualIndexValue = value;\n        maxWidth = Math.max(i - firstEqualIndex, maxWidth);\n        firstEqualIndex = i;\n      }\n    }\n    return Math.max(indexLength - firstEqualIndex, maxWidth);\n  }\n\n  private tensorShapeFromTensor(\n      t: TypedArray, tShape: number[], isPartial = true) {\n    if (tShape.length === 0) {\n      if (t[0] === -1) {\n        return [];\n      }\n      throw new Error(\n          `The only valid scalar shape tensor is the fully unknown shape specified as -1.`);\n    }\n    // MakePartialShape/MakeShapeHelper.\n    return makeShape(t, isPartial);\n  }\n\n  private calculateOutputSize(firstDim: number) {\n    const valueShape = this.valuesShape;\n    const defaultValueShape = this.defaultValueShape;\n\n    backend_util.validateDefaultValueShape(defaultValueShape, valueShape);\n\n    const shape = this.tensorShapeFromTensor(this.shape, this.shapeShape);\n    const outputShape = backend_util.combineRaggedTensorToTensorShapes(\n        this.raggedRank, shape, valueShape);\n\n    const result = outputShape;\n\n    if (result[0] < 0) {\n      result[0] = firstDim;\n    }\n    for (let i = 1; i <= this.raggedRank; ++i) {\n      if (result[i] < 0) {\n        result[i] = this.getMaxWidth(i);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * The outputIndex represents the index in the output tensor\n   * where the first element of a particular dimension would be written.\n   * If it is -1, it indicates that the index is out of scope.\n   * Example, given firstDimension = 10, firstDimensionOutput = 6,\n   * and outputIndexMultiplier = 100:\n   * result = [0 100 200 300 400 500 -1 -1 -1 -1]\n   * If firstDimensionOutput = 11 instead, then:\n   * result = [0 100 200 300 400 500 600 700 800 900]\n   */\n  private calculateFirstParentOutputIndex(\n      firstDimension: number, outputIndexMultiplier: number,\n      firstDimensionOutput: number) {\n    const minDimension = Math.min(firstDimension, firstDimensionOutput);\n    const result: number[] = [];\n    let currentOutputIndex = 0;\n    for (let i = 0; i < minDimension;\n         ++i, currentOutputIndex += outputIndexMultiplier) {\n      result.push(currentOutputIndex);\n    }\n    for (let i = minDimension; i < firstDimension; ++i) {\n      result.push(-1);\n    }\n    util.assert(\n        result.length === firstDimension,\n        () => 'Final length of result must be equal to firstDimension.');\n\n    return result;\n  }\n\n  private calculateOutputIndexRowSplit(\n      rowSplit: TypedArray, parentOutputIndex: number[],\n      outputIndexMultiplier: number, outputSize: number) {\n    const rowSplitSize = rowSplit.length;\n    const result: number[] = [];\n    for (let i = 0; i < rowSplitSize - 1; ++i) {\n      const rowLength = rowSplit[i + 1] - rowSplit[i];\n      let realLength = Math.min(outputSize, rowLength);\n      let parentOutputIndexCurrent = parentOutputIndex[i];\n\n      if (parentOutputIndexCurrent === -1) {\n        realLength = 0;\n      }\n      for (let j = 0; j < realLength; ++j) {\n        result.push(parentOutputIndexCurrent);\n        parentOutputIndexCurrent += outputIndexMultiplier;\n      }\n      for (let j = 0; j < rowLength - realLength; ++j) {\n        result.push(-1);\n      }\n    }\n    if (rowSplitSize > 0 && result.length !== rowSplit[rowSplitSize - 1]) {\n      throw new Error('Invalid row split size.');\n    }\n\n    return result;\n  }\n\n  // Calculate the output index of the first element of a list.\n  // The parentOutputIndex is the same computation for the previous list.\n  // -1 indicates an element or list that is out of range.\n  // The outputIndexMultiplier is the number of output indices one moves\n  // forward for each column.\n  // E.g., given:\n  // valueRowIds:[0 1 2 2 2 3 5 5 6]\n  // parentOutputIndex:[1000 1100 2000 2100 -1 3000 4000]\n  // outputIndexMultiplier: 10\n  // outputSize: 2\n  // You get:\n  // result = [1000 1100 2000 2010 -1 2100 -1 -1 3000]\n  // result[0] = parentOutputIndex[valueRowIds[0]]\n  // result[1] = parentOutputIndex[valueRowIds[1]]\n  // result[2] = parentOutputIndex[valueRowIds[2]]\n  // result[3] = parentOutputIndex[valueRowIds[2] + 10]\n  // result[4] = -1 because it is the third element the size is 2.\n  // result[5] = parentOutputIndex[valueRowIds[3]]\n  // result[6] = -1 because parentOutputIndex[valueRowIds[6]] == -1\n  // result[7] = -1 because parentOutputIndex[valueRowIds[6]] == -1\n  // result[8] = parentOutputIndex[valueRowIds[7]]\n  private calculateOutputIndexValueRowID(\n      valueRowIds: TypedArray, parentOutputIndex: number[],\n      outputIndexMultiplier: number, outputSize: number) {\n    const indexSize = valueRowIds.length;\n    const result: number[] = [];\n    if (indexSize === 0) {\n      return [];\n    }\n\n    let currentOutputColumn = 0;\n    let currentValueRowId = valueRowIds[0];\n\n    if (currentValueRowId >= parentOutputIndex.length) {\n      throw new Error(\n          `Got currentValueRowId=${currentValueRowId}, which is not less than ${\n              parentOutputIndex.length}`);\n    }\n\n    let currentOutputIndex = parentOutputIndex[currentValueRowId];\n    result.push(currentOutputIndex);\n    for (let i = 1; i < indexSize; ++i) {\n      const nextValueRowId = valueRowIds[i];\n      if (nextValueRowId === currentValueRowId) {\n        if (currentOutputIndex >= 0) {\n          ++currentOutputColumn;\n          if (currentOutputColumn < outputSize) {\n            currentOutputIndex += outputIndexMultiplier;\n          } else {\n            currentOutputIndex = -1;\n          }\n        }\n      } else {\n        currentOutputColumn = 0;\n        currentValueRowId = nextValueRowId;\n\n        if (nextValueRowId >= parentOutputIndex.length) {\n          throw new Error(\n              `Got nextValueRowId=${nextValueRowId} which is not less than ${\n                  parentOutputIndex.length}`);\n        }\n\n        currentOutputIndex = parentOutputIndex[nextValueRowId];\n      }\n      result.push(currentOutputIndex);\n    }\n\n    if (result.length !== valueRowIds.length) {\n      throw new Error('Invalid row ids.');\n    }\n\n    return result;\n  }\n\n  private calculateOutputIndex(\n      dimension: number, parentOutputIndex: number[],\n      outputIndexMultiplier: number, outputSize: number) {\n    const rowPartitionTensor = this.getRowPartitionTensor(dimension);\n    const partitionType = this.getRowPartitionTypeByDimension(dimension);\n    switch (partitionType) {\n      case RowPartitionType.VALUE_ROWIDS:\n        return this.calculateOutputIndexValueRowID(\n            rowPartitionTensor, parentOutputIndex, outputIndexMultiplier,\n            outputSize);\n      case RowPartitionType.ROW_SPLITS:\n        if (rowPartitionTensor.length - 1 > parentOutputIndex.length) {\n          throw new Error(`Row partition size is greater than output size: ${\n              rowPartitionTensor.length - 1} > ${parentOutputIndex.length}`);\n        }\n        return this.calculateOutputIndexRowSplit(\n            rowPartitionTensor, parentOutputIndex, outputIndexMultiplier,\n            outputSize);\n      default:\n        throw new Error(\n            `Unsupported partition type: ${RowPartitionType[partitionType]}`);\n    }\n  }\n\n  private getFirstDimensionSize() {\n    const firstPartitionTensor = this.rowPartitionValues[0];\n    if (this.rowPartitionTypes.length === 0) {\n      throw new Error('No row_partition_types given.');\n    }\n    const firstPartitionType = this.rowPartitionTypes[0];\n    switch (firstPartitionType) {\n      case RowPartitionType.FIRST_DIM_SIZE:\n        return firstPartitionTensor[0];\n      case RowPartitionType.VALUE_ROWIDS:\n        throw new Error('Cannot handle VALUE_ROWIDS in first dimension.');\n      case RowPartitionType.ROW_SPLITS:\n        return this.rowPartitionValuesShapes[0][0] - 1;\n      default:\n        throw new Error(\n            `Cannot handle type ${RowPartitionType[firstPartitionType]}`);\n    }\n  }\n\n  compute(): [number[], TypedArray] {\n    const firstPartitionTensor = this.rowPartitionValues[0];\n    if (firstPartitionTensor.length <= 0) {\n      throw new Error(\n          'Invalid first partition input. ' +\n          'Tensor requires at least one element.');\n    }\n    const firstDimension = this.getFirstDimensionSize();\n    const outputSize = this.calculateOutputSize(firstDimension);\n    const multiplier: number[] = new Array(this.raggedRank + 1);\n\n    multiplier[multiplier.length - 1] = 1;\n    for (let i = multiplier.length - 2; i >= 0; --i) {\n      multiplier[i] = multiplier[i + 1] * outputSize[i + 1];\n    }\n    // Full size of the tensor.\n    const outputShape: number[] = makeShape(outputSize, false);\n    const outputTensor =\n        util.getArrayFromDType(\n            this.valuesDType, util.sizeFromShape(outputShape)) as TypedArray;\n\n    const fullSize = multiplier[0] * outputSize[0];\n    if (fullSize > 0) {\n      let outputIndex = this.calculateFirstParentOutputIndex(\n          firstDimension, multiplier[0], outputSize[0]);\n      for (let i = 1; i <= this.raggedRank; ++i) {\n        const newOutputIndex = this.calculateOutputIndex(\n            i - 1, outputIndex, multiplier[i], outputSize[i]);\n        outputIndex = newOutputIndex;\n      }\n\n      this.setOutput(this.raggedRank, outputIndex, outputTensor, outputShape);\n    }\n\n    return [outputShape, outputTensor];\n  }\n  setOutput(\n      raggedRank: number, outputIndex: number[], outputTensor: TypedArray,\n      outputShape: number[]) {\n    if (outputTensor.length === 0) {\n      return;\n    }\n\n    const valuesBase = this.values;\n    const outputBase = outputTensor;\n\n    let elementShape = outputShape.slice();\n    elementShape = elementShape.slice(raggedRank + 1);\n    const valueElementSize = util.sizeFromShape(elementShape);\n    const outputIndexSize = outputIndex.length;\n\n    // Broadcast the default value to value_element_size.  (We can skip this\n    // if defaultValueTensor.size == 1, since we use fill when that's true.)\n    let defaultValue = this.defaultValue;\n    if (defaultValue.length !== valueElementSize && defaultValue.length !== 1) {\n      const srcShape = this.defaultValueShape;\n      tidy(() => {\n        const defaultValueTensor = reshape(defaultValue, srcShape);\n        const bCastDefault = broadcastTo(defaultValueTensor, elementShape);\n        defaultValue = bCastDefault.dataSync();\n      });\n    }\n\n    // Loop through the outputIndex array, finding contiguous regions that\n    // should be copied.  Once we find the end of a contiguous region, copy it\n    // and add any necessary padding (with defaultValue).\n    let srcStart = 0;  // Start of contiguous region (in values)\n    let dstStart = 0;  // Destination for contiguous region (in output)\n    let dstEnd = 0;    // Destination for contiguous region (in output)\n    for (let srcI = 0; srcI <= outputIndexSize; ++srcI) {\n      // dstI is the destination where the value at srcI should be copied.\n      let dstI = srcI < outputIndexSize ? outputIndex[srcI] : -1;\n\n      // If we're still in a contiguous region, then update dstEnd go to the\n      // next srcI.\n      if (dstI === dstEnd) {\n        ++dstEnd;\n        continue;\n      }\n\n      // We found the end of contiguous region.  This can be because we found\n      // a gap (dstI > dstEnd), or a source value that shouldn't be copied\n      // because it's out-of-bounds (dstI == -1), or the end of the tensor\n      // (dstI === -1).\n      if (dstStart < dstEnd) {\n        // Copy the contiguous region.\n        const src = valuesBase.subarray(srcStart * valueElementSize);\n        const dst = outputBase.subarray(dstStart * valueElementSize);\n        const nVals = (dstEnd - dstStart) * valueElementSize;\n        copyArray(dst, src, nVals);\n      }\n\n      // Add any necessary padding (w/ defaultValue).\n      if (srcI >= outputIndexSize) {\n        // We reached the end of values: pad to the end of output.\n        const outputSize = outputTensor.length;\n        dstI = Math.floor(outputSize / valueElementSize);\n      }\n      if (dstI > dstEnd) {\n        if (this.defaultValue.length === 1) {\n          outputBase\n              .subarray(dstEnd * valueElementSize, dstI * valueElementSize)\n              .fill(this.defaultValue[0]);\n          dstEnd = dstI;\n        } else {\n          while (dstI > dstEnd) {\n            const dst = outputBase.slice(dstEnd * valueElementSize);\n            copyArray(dst, defaultValue, valueElementSize);\n            ++dstEnd;\n          }\n        }\n      }\n\n      // Update indices.\n      if (dstI < 0) {\n        // srcI should be skipped -- leave it out of the contiguous region.\n        srcStart = srcI + 1;\n        dstStart = dstEnd;\n      } else {\n        // srcI should be copied -- include it in the contiguous region.\n        srcStart = srcI;\n        dstStart = dstEnd;\n        dstEnd = dstStart + 1;\n      }\n    }\n  }\n}\n\nfunction copyArray(dst: TypedArray, src: TypedArray, size: number) {\n  for (let i = 0; i < size; i++) {\n    dst[i] = src[i];\n  }\n}\n\nfunction makeShape(shape: number[]|TypedArray, isPartial: boolean) {\n  const out: number[] = [];\n  for (let dim of shape) {\n    if (dim < 0) {\n      if (!isPartial) {\n        throw new Error(`Dimension ${dim} must be >= 0`);\n      }\n      if (dim < -1) {\n        throw new Error(`Dimension ${dim} must be >= -1`);\n      }\n      dim = -1;\n    }\n    out.push(dim);\n  }\n\n  return out;\n}\n\nexport function raggedTensorToTensorImpl(\n    shape: TypedArray, shapesShape: number[], values: TypedArray,\n    valuesShape: number[], valuesDType: DataType, defaultValue: TypedArray,\n    defaultValueShape: number[], rowPartitionValues: TypedArray[],\n    rowPartitionValuesShapes: number[][],\n    rowPartitionTypes: string[]): [number[], TypedArray] {\n  return new RaggedTensorToTensorOp(\n             shape, shapesShape, values, valuesShape, valuesDType, defaultValue,\n             defaultValueShape, rowPartitionValues, rowPartitionValuesShapes,\n             rowPartitionTypes)\n      .compute();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}